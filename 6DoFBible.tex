%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LaTeX book template                           %%
%% Author:  Amber Jain (http://amberj.devio.us/) %%
%% License: ISC license                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{report}
\usepackage[letterpaper, total={6in, 8in}]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{tikz}
\usetikzlibrary{fadings}
\usetikzlibrary{patterns}
\usetikzlibrary{shadows.blur}
\usetikzlibrary{shapes}
\usepackage{indentfirst}
\usepackage{mathdots}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{extarrows}
\usepackage{setspace}
\usepackage{matlab-prettifier}
\usepackage{csquotes}
\usepackage{biblatex}
\addbibresource{references.bib}
\usepackage{float}
\usepackage{gensymb}
\usepackage{amsfonts}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source: http://en.wikibooks.org/wiki/LaTeX/Hyperlinks %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{mathtools}
\mathtoolsset{showonlyrefs} 

%% GLOSSARY:
\usepackage[toc]{glossaries}

\glsdisablehyper

\makeglossaries

%\setglossarypreamble[\acronymtype]{\glssetwidest{RMS}}
%\setabbreviationstyle[jargon]{long-short}
%\glssetcategoryattribute{jargon}{glossdescfont}{emph} % Remove emph in glossary by using it again

%examples to reference:
\newglossaryentry{DoF}
{
    name=Degree of Freedom,
    first = {\textit{Degree of Freedom}},
    description={A free direction of movement for a vehicle. These can be translational or rotational directions}
}
\newacronym{dof}{DoF}{Degree of Freedom}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 'dedication' environment: To add a dedication paragraph at the start of book %
% Source: http://www.tug.org/pipermail/texhax/2010-June/015184.html            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newenvironment{dedication}
{
   \cleardoublepage
   \thispagestyle{empty}
   \vspace*{\stretch{1}}
   \hfill\begin{minipage}[t]{0.66\textwidth}
   \raggedright
}
{
   \end{minipage}
   \vspace*{\stretch{3}}
   \clearpage
}

%% CODE STUFF
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=t,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstMakeShortInline[style=Matlab-editor]"

\renewcommand\lstlistingname{Code Listing}
\renewcommand{\lstlistlistingname}{Code Listings}

\mlttfamily

\setlength{\parskip}{12pt}

\setlength{\headheight}{15pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter quote at the start of chapter        %
% Source: http://tex.stackexchange.com/a/53380 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\@chapapp}{}% Not necessary...
\newenvironment{chapquote}[2][2em]
  {\setlength{\@tempdima}{#1}%
   \def\chapquote@author{#2}%
   \parshape 1 \@tempdima \dimexpr\textwidth-2\@tempdima\relax%
   \itshape}
  {\par\normalfont\hfill--\ \chapquote@author\hspace*{\@tempdima}\par\bigskip}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% First page of book which contains 'stuff' like: %
%  - Book title, subtitle                         %
%  - Book author name                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Book's title and subtitle
\title{\Huge \textbf{Flight Dynamics Bible}  \\ \huge Everything about 6 Degree of Freedom Modeling}

% Author
\author{\textsc{Hudson Reynolds}
\and
\textsc{Preston Wright}
}

\begin{document}

\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\fancyhead[R]{}
\fancyhead[L]{\thechapter\ --\ \leftmark}

%\frontmatter
\maketitle

%% Things to do:
% clean up glossaries, explore glossaries extra
% finish the 6-DoF Section, add code and attach code in google drive as well

%
\begin{dedication}
    This document is dedicated to Purdue Space Program Liquids. PSP Liquids has given us a vast amount of experience and means to explore the realm of Flight Dynamics. We hope that we can contribute to the wealth of information provided by PSP with this document.
\end{dedication}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auto-generated table of contents, list of figures and list of tables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{spacing}{.5}
    \tableofcontents
    %\listoftables
    \listoffigures
    \lstlistoflistings
\end{spacing}

%\mainmatter

%%%%%%%%%%%
% Preface %
%%%%%%%%%%%
\chapter*{Preface}
Preston and I began working on the Flight Dynamics sub-team in the fall of 2023. From May 2024 to January 2025, we focused our efforts on creating a 6-\gls{dof} model from scratch. During this time, we learned a lot about the mathematics and physics involved in creating such a model. We were often faced with frustration with different conventions and poor explanations of certain topics, all of which were exacerbated by the difficulty of what we were learning. This made much of the material intractable. In this document, we hope to provide detailed explanations of all the necessary concepts in one place to make this journey easier for those who may need it in the future. 

Furthermore, we hope that this document can be used by those outside the realm of flight dynamics to better understand the methodologies and inner workings of a 6-\gls{dof} model. Often, we have seen that a 6-\gls{dof} model is treated as a ‘black box’, where inputs go in and outputs come out. We hope that this document can provide a level of understanding adequate to allow greater collaboration between those working within and outside of flight dynamics.

In this document, we will be using excerpts of MATLAB script in some examples (code less than a page is included inline, and longer code is in the appendix) but our hope is that our explanations are thorough enough to facilitate the creation of a 6-\gls{dof} in any coding language. MATLAB facilitates the use of quite short code because of the number of built-in functions, but we include derivations for most of these equations or sources describing these derivations.

To use this document to its fullest extent, we recommend that you write scripts as you learn and use this document for reference and as a guide as you build or improve your own models.

In this first edition, we cover primarily the translational and rotational dynamics needed to set up a 6-\gls{dof} model. We also touch on subjects relating to the implementation of these equations in MATLAB and best practices. These are, in our opinion, the fundamental things that need to be understood before working on other aspects of a flight dynamics model. As such, these subjects comprise a large majority of both the effort and the length of the first edition.

Some other areas are also covered in this document but are not fully explained because Preston and I do not have the experience to give full authority on these subjects. However, as we learn more, this document is growing every day. In future editions, we hope to expand some of these other sections, especially those related to aerodynamics and control theory, to better serve those in the future who may hope to recreate the work we have done here.

% \section*{About the companion website}
% The website\footnote{\url{https://github.com/amberj/latex-book-template}} for this file contains:
% \begin{itemize}
%   \item A link to (freely downlodable) latest version of this document.
%   \item Link to download LaTeX source for this document.
%   \item Miscellaneous material (e.g. suggested readings etc).
% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Give credit where credit is due. %
% Say thanks!                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgments}
\begin{itemize}
\item We would like give special thanks to Prof. Cunningham and Prof. Frueh for their help in reviewing our 6-\gls{dof} Model. Professor Frueh's notes have been especially helpful in compiling the information present in this document.

\end{itemize}

\chapter{Overview}

\begin{chapquote}{Carl Sagan}
''If you wish to make an apple pie from scratch, you must first invent the universe.''
\end{chapquote}

In much the same way, we must construct all of the mathematical background required to make a 6-\gls{dof} from the ground up. This chapter details the general requirements and an outline of the process we will be following.

\section{Necessary Background}
The goal of this document is to provide a comprehensive overview of the process and means of creating, maintaining, and building on a 6 Degree of Freedom model. Although we strive to make the document as easy as possible to understand, there are some instances where technical jargon is necessary and a strong understanding of mathematical concepts is required. 

Any time important technical jargon is required, we will \textit{italicize} the word for recognition. It is important to learn these terms to effectively and concisely describe your work. That being said, we attempt to keep the usage of jargon to a minimum. Because we italicize words in this manner, we choose to additionally underline any book titles present in the text. A glossary with these terms has also been added so that all of these words are included in a single location. 

To aid in comprehensibility, we have added sources that we find especially useful and avoided the use of superfluous sources. These sources are hyperlinked for ease of access. In addition, useful links and footnotes have been highlighted in red boxes to be easily located. 

To fully comprehend and successfully use this document, it is recommended that you have a good understanding of calculus, linear algebra, and calculus-based physics. A rudimentary understanding of differential equations and dynamics will also prove useful but is not strictly required.

We also choose to use notation that is used in the Purdue AAE classes. Some of these may be unfamiliar if you have not encountered this coursework yet, but we do our best to describe notation throughout this document.

Some concepts will arise in this document that are derived from graduate-level coursework and complex mathematics. In these instances, we may not attempt to derive the background and full understanding, but rather only what is necessary for building a 6-\gls{dof} model. In these cases, we also try to link to source material if you are inclined to learn more about those topics.

\section{Why 6-DoF?}
Let’s start off with some terminology in this section. A \gls{dof} refers to the number of ways an object can move in space. A more technically precise and rigorous definition defines this as the number of independent parameters that define the state. It is common to see 1-\gls{dof}, 3-\gls{dof}, and 6-\gls{dof} models all used in aerospace applications. Each of these are useful constructs, and often a simulation with more degrees of freedom is not necessarily better, depending on the scenario.
\subsection{1-DoF}
The first modeling that is often done for the sizing of rockets may use 1-\gls{dof} modeling. In this type of model, there is only one axis along which an object may translate or rotate about. In this case of rocket modeling, the only degree of freedom is the vertical height of the rocket. The goal of this type of model is mainly to provide a heuristic for determining rocket performance in the very preliminary stages of sizing by estimating the maximum altitude they can achieve.

Another example of this type of model is a simple mass-spring system along one axis. Such models may be useful for estimating the vibrations of bodies or as a first order approximation of fuel slosh.

We will use the example of a 1-\gls{dof} in section 2.1 to explain the creation of equations of motion in the simplest way. However, these models are often too constrained to give the most valuable information about a system, which is why 3-\gls{dof} and 6-\gls{dof} models are more often used.
\subsection{3-DoF}
After 1-\gls{dof}, the next step up is often a 3-\gls{dof} model. This type of model should be familiar to all flight dynamics members, as it is the subject of our onboarding project. In a 3-\gls{dof} model, there may be any combination of translational degrees of freedom and rotational degrees of freedom.

Often, 3-\gls{dof} modelling is utilized when either the rotational dynamics or translational dynamics of an object are considered unimportant. One example of this may be the calculation of an interplanetary transfer. The primary concern of the simulation is not the orientation of the satellite, but rather the location and velocity of the satellite at various points in 3D space. 

Another example of this type of model is planar motion. Often, problems in engineering are constrained in some way. Very often, we can consider one of the translational degrees of freedom to be non-important to the problem. This simplification allows us to greatly reduce the scope of the problem. One consequence of this action is that rotations are only permitted in a single axis. With two translational and one rotational degree of freedom, we can create useful models of many systems without great complexity.

Although the rest of this document will discuss 6-\gls{dof} models, really consider if you need that full complexity for your model! Often, a 3-\gls{dof} model is perfectly adequate for a large variety of problems without the hassle incurred by a 6-\gls{dof} model. 
\subsection{6-DoF}
6-\gls{dof} models are the most complex representation of a mechanical system. In 3D-space, there are only 6 possible degrees of freedom, and we simulate the dynamics in all of them.

Doing so is quite a difficult challenge, but it is not insurmountable. With careful planning, it is possible to gain an appreciation and understanding of the dynamics of a full 3D system. Doing so allows unrivaled modeling potential. In the case of a rocket, the primary reason that modeling in 6-\gls{dof} is so important is because it allows us to analyze the aerodynamic stability of the system. In both 1-\gls{dof} and 3-\gls{dof} modeling, this important aspect of the system is largely neglected.
\subsection{Structure Hierarchy of a 6-DoF}
An ideal 6-\gls{dof} not only models the motion of a vehicle through the atmosphere as accurately as possible but is also well-structured and easily readable. Strict adherence to an agreed upon and appropriate set of coding standards is essential for a successful program. These cover everything from naming conventions to heading structure, and make the integration of codes from multiple contributors more seamless.

\newglossaryentry{state vector}
{
    name=state vector,
    first = {\textit{state vector}},
    description={A vector containing information about the position and velocity of a body at a given time. This vector can also include more information, such as the angular velocity and quaternion. Generally, this vector includes all quantities needed to be integrated to find the new state},
    see={quaternion}
}

Within the structure of a 6-\gls{dof}, there are three main, large “blocks” of code that are executed in sequence. The first is the initialization section. This is where all known, fixed parameters of the vehicle, atmosphere, and physics are initialized to be called later in the program. The second section is the integrator. This block utilizes a certain integration scheme to step through time, calculating the derivatives of the vehicle’s \gls{state vector}. Within the integrator, there are two major sub-blocks corresponding to two sets of dynamics: the forces and the moments. The forces section takes on the more familiar Newtonian Dynamics – regarding Position, Velocity, and Acceleration - that are seen in a high school physics class. The moments section takes on the Attitude Dynamics – orientation in space - of the vehicle. This can take the form of either Euler Angles or Parameters, which will be discussed further later. The final block is the visualizer block. This section writes pertinent information to matrices, animates the movement of the vehicle from launch to land, and outputs graphs of important metrics for the user to visualize.

Each of the previously mentioned sections will be discussed in more detail throughout this document.

\chapter{Newtonian Dynamics}\label{sec: Newtonian Dynamics}
\begin{chapquote}{Isaac Newton}
''I can calculate the motion of heavenly bodies, but not the madness of people.''
\end{chapquote}
The first step when approaching any physics problem of this type is to consider the Newtonian dynamics of the system. In our case, we define Newtonian dynamics as the translational dynamics of the system as well as the moments acting on the system. This differs from particle dynamics because we are considering a rigid body which can exhibit rotation. The exploration of this rotation will be explored in much more detail in Section \ref{sec:attitude dynamics}. 
\section{The 1-DoF Case}\label{sec: The 1DoF Case}
To begin our exploration of Newtonian dynamics, we will return to the example of the 1-\gls{dof} which we used earlier. Our goal with this is to use a simple example you are familiar with from high school physics and bring it up to speed with the terminology and techniques we will use for more complex analysis.

In Figure 1 below, we show an example of a very simple 1-\gls{dof} system free body diagram. We will use this example to explain the process of calculating the Newtonian dynamics in 1-dimension, which we then expand to the full 3D case. 

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{figure}[ht]
    \centering
    %\includegraphics[width=0.5\linewidth]{}
    
    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,308); %set diagram left start at 0, and has height of 308

%Rounded Rect [id:dp5842362308374554] 
\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ,draw opacity=1 ][fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (260,144) .. controls (260,130.75) and (270.75,120) .. (284,120) -- (376,120) .. controls (389.25,120) and (400,130.75) .. (400,144) -- (400,216) .. controls (400,229.25) and (389.25,240) .. (376,240) -- (284,240) .. controls (270.75,240) and (260,229.25) .. (260,216) -- cycle ;
%Straight Lines [id:da22630541270037763] 
\draw [line width=1.5]    (330,180) -- (330,63) ;
\draw [shift={(330,60)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Straight Lines [id:da4912651471508729] 
\draw [line width=1.5]    (340,180) -- (340,217) ;
\draw [shift={(340,220)}, rotate = 270] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Shape: Circle [id:dp11471774870022611] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (313.44,180) .. controls (313.44,170.85) and (320.85,163.44) .. (330,163.44) .. controls (339.15,163.44) and (346.56,170.85) .. (346.56,180) .. controls (346.56,189.15) and (339.15,196.56) .. (330,196.56) .. controls (320.85,196.56) and (313.44,189.15) .. (313.44,180) -- cycle ;
%Straight Lines [id:da07105152032768414] 
\draw    (130,223) -- (130,185) ;
\draw [shift={(130,183)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da477096952774564] 
\draw    (130,223) -- (168,223) ;
\draw [shift={(170,223)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da5415789935745218] 
\draw [line width=1.5]    (320,180) -- (320,257) ;
\draw [shift={(320,260)}, rotate = 270] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;

% Text Node
\draw (331,220.4) node [anchor=north west][inner sep=0.75pt]    {$F_{D}$};
% Text Node
\draw (321,42.4) node [anchor=north west][inner sep=0.75pt]    {$F_{T}$};
% Text Node
\draw (171,215.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (131,162.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (311,260.4) node [anchor=north west][inner sep=0.75pt]    {$F_{g}$};


\end{tikzpicture}
    \caption{1-DoF Forces on a body}
    \label{Figure 1}
\end{figure}

In Figure \ref{Figure 1}, a total of three forces are shown, all of which act along the  direction. The colinearity of all these forces is what makes this a 1-\gls{dof} model. The three forces shown are the thrust force, the drag force, and the gravity force.

Following what you may do in an introductory physics class, we will describe each of these forces via their functional form. These are described in Table \ref{Force Equations 1 DoF}. 

\begin{table}
\centering
\caption{Functional Form of Force Equations}
\label{Force Equations 1 DoF}
\begin{tabular}{l | l}
Force & Functional Form \\
\hline
 $F_g$&  $-mg$\\
 $F_D$&  $-\frac{1}{2} \rho_{\infty} V^2_{\infty}SC_D$\\
 $F_T$&  $F_T\cdot[1-u(t-t_b)], t\le0$\\

\end{tabular}

\end{table}
\newglossaryentry{freestream}
{
    name=freestream,
    first = {\textit{freestream}},
    description={A freestream quantity is one that is far away from the body, such that the influences of the body are negligible. For example, freestream velocity is the velocity that would be seen outside the influence of the body at the same conditions}
}

\newglossaryentry{ref area}
{
    name=reference area,
    first = \textit{reference area},
    description={An area that is used to define a characteristic area of an object in aerodynamics. This is used to normalize quantities such as lift and drag}
    }
The notation here is important to understand. In future AAE classes at Purdue, this is likely the notation that you will see. Terms with the subscript $\infty$ denote \gls{freestream} quantities, those that are freely flowing far away from the body of interest. Also of note is the unit step function, which is a function which has value zero until reaching time $t_b$, where it thereafter equals one. The quantity  $\rho$ refers to the density of the fluid, and $S$ to the \gls{ref area}. The \textit{drag coefficient} is $C_D$, a term which encapsulates the very complex nature of the fluid flow around an object. Calculating the value of  will be explored more deeply in later sections of this document. For now, we may assume a constant value.

It is helpful to think about these quantities as vectors, because we can add them together to achieve a resultant.\footnote{More formally, we define this as a linear space, where multiplicative and additive properties are preserved. This formal definition allows us to apply this to any arbitrarily number of dimensions. } In the 1-dimensional case this is quite trivial since all vectors along the $\hat{y}$ unit vector, but this will become increasingly important as we move to higher dimensions.
\subsection{Numerical Integration in the 1-DoF}\label{sec: Numerical Integration in the 1DoF}
Now we will move into something that you may have not seen before. Given all the forces, we normally apply Newton’s 2\textsuperscript{nd} Law, $\sum{\vec{F}}=m\vec{a}$ , to arrive at an expression for the acceleration as shown in \eqref{eq2}. Doing so might look something like this:
\begin{gather}
F_T \cdot [1-u(t-t_b)]-\frac{1}{2}\rho_{\infty}V_{\infty}^2SC_D-mg=m\vec{a}\label{eq1} \\
\vec{a}=\frac{F_T \cdot [1-u(t-t_b)]-\frac{1}{2}\rho_{\infty}V_{\infty}^2SC_D}{m}-g\label{eq2}
\end{gather}
 From here, we use integration to find the velocity and then position of the object with time. Formally, we might define this formally as:
 $$\vec{V}=\int{\vec{a}}{dt}$$
However, you may notice something strange with our equation. In our expression for acceleration, we need to know the velocity. However, we do not know the velocity without integrating the equation first. This puts us in a chicken v. egg situation, so we must take a different approach to the problem. \footnote{Sometimes systems like this can be solved with traditional ODE methods. However, most complex systems like our 6-\gls{dof} have no known analytical solutions. We will focus on numerical integration because it will be more useful in general. }

The way we resolve this is to make an approximation of the solution in a process called \textit{Numerical Integration. }Here, we will outline the simplest type of numerical integration, known as Euler’s Method. This section aims to show how to implement Euler’s method in code, and the mathematical reasoning will be given a more formal treatment in section 5. We will describe more complex numerical integration schemes and why you might want to use them, but it’s good to see the code for a simple case first.

Euler’s Method involves discretizing our time interval. You may remember the concept of a Riemann Sum from calculus, where you approximate an integral in discrete time steps. We will take a similar approach with Euler’s Method. Euler’s method is applicable to solving first order ordinary differential equations (ODE’s). However, in our problem, we have a second order differential equation, because $\vec{a}=\ddot{y}$.

To resolve this issue, we will make this one differential equation into a system of first order differential equations. In general, we can convert an nth-order ODE into a system of n first-order ODEs.

In this case, we define a variable, . Now, we can express equation \eqref{eq2} as a system of two differential equations:

\begin{gather}\label{system}
        \dot{v}=\frac{F_T \cdot [1-u(t-t_b)]-\frac{1}{2}\rho_{\infty}V_{\infty}^2SC_D}{m}-g\\
    \dot{y}=v
\end{gather}

Now, we will apply Euler’s method to solve the problem. We will use the following steps to do so, using equation \eqref{system}as our example:

1. Rewrite the system in Leibniz notation, where $\dot{x}=\frac{dx}{dt}$.

2. Perform separation of variables, to arrive at $dx=v\cdot dt$.

3. Discretize the equation by ‘converting’  $dx$ and $dt$ to $\Delta x$ and $\Delta t$.\footnote{Note that we are not ‘converting’ in the sense of an equality, since the equations are no longer equivalent when we convert a differential element into a discrete one. We are just making an approximation of the true solution. Luckily, numerical integration schemes can get us quite close to true solutions. }

4. Rewrite $\Delta x$ as $x_{new}-x_{old}$. We can rearrange the equation as $x_{new}=v\cdot \Delta t + x_{old}$

5. To start, we define an initial state. This initial state will be the first value of $x_{old}$. 

6. Iterate through values of $\Delta t$ until the desired time of simulation is achieved.

We follow the same process for the integration of acceleration to find the velocity. Of note, we will use the previous value of $v$ in the computation of the new acceleration. Note that a more formal definition of Euler’s method is given in section 5.1.

We also show this example in MATLAB Script \ref{Script 1} below. Note that $\frac{1}{2}\rho_{\infty}SC_D$ is called $k$ in the script for simplicity. This simplification assumes that $\rho_{\infty}$ and the $C_D$ are constant, which we will later see is a quite poor assumption but is okay for a first approximation.

\lstset{style=mystyle}

\lstinputlisting[language=Matlab, caption=1 DoF]{OneDofEuler.m}\label{Script 1}

There are a few important things to note about the MATLAB implementation of the script. Firstly, the only force that is defined outside of the loop is gravity, because the magnitude and direction of this force is independent of the current state of the system. We contrast this with the drag force and the thrust, which must be calculated on every iteration through the algorithm to find an updated value for the force.

We also note the use of the Heaviside function. This is functionally identical to a unit step function, just a different notation.

\section{The 3-DoF Case}\label{sec: 3DoF Case}
\subsection{Vectors in the 3-DoF Case}
For particle dynamics, the most complex case is full 3D translational motion. Luckily, nothing very fundamental changes as compared to the 1-\gls{dof} case. The most important difference is the use of vector notation for compactness and clarity of mathematics and code. For position ($\vec{r}$), velocity ($\vec {v}$), and acceleration ($\vec{a}$), we represent them as tri-dimensional column vectors:

\begin{gather}
    \vec{r}=\begin{bmatrix}
        x_1\\
        x_2\\
        x_3
    \end{bmatrix},
    \vec{v}=\begin{bmatrix}
        \dot{x}_1\\
        \dot{x}_2\\
        \dot{x}_3\\
    \end{bmatrix},
        \vec{a}=\begin{bmatrix}
        \ddot{x}_1\\
        \ddot{x}_2\\
        \ddot{x}_3\\
    \end{bmatrix}
\end{gather}
This is done not only for the sake of compactness, but also to facilitate the use of matrix operations for translation between reference frames. This concept is further explored in section 3. For this reason, expressing these elements in vectors will become crucial as we move forward. In MATLAB, we express a tri-dimensional column vector as:
\begin{lstlisting}[language=Matlab]
pos=[0;0;0];
\end{lstlisting}
Where each semicolon represents a new row of the vector. We define a row vector by using a comma instead of a semicolon: 
\begin{lstlisting}[language=Matlab]
pos=[0,0,0];
\end{lstlisting}
Often, it is useful to convert between a row and column vector in MATLAB because some functions will expect the input to be in a different format. We can do so with a transposition. In MATLAB, this looks like: 
\begin{lstlisting}
pos=[0,0,0];
\end{lstlisting}
\subsection{Vector directions in the 3-DoF}\label{sec: vector directions in the 3DoF}
We present below a modified version of the 1-\gls{dof} below in full 3D in Figure \ref{fig:3 DoF Forces}.

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt       

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,308); %set diagram left start at 0, and has height of 308

%Shape: Cube [id:dp15885218660825062] 
\draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=0.15 ] (260,129.92) -- (289.92,100) -- (380,100) -- (380,190.08) -- (350.08,220) -- (260,220) -- cycle ; \draw   (380,100) -- (350.08,129.92) -- (260,129.92) ; \draw   (350.08,129.92) -- (350.08,220) ;
%Straight Lines [id:da7537274804871096] 
\draw    (160,210) -- (160,172) ;
\draw [shift={(160,170)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da28051238395124845] 
\draw    (160,210) -- (194,210) ;
\draw [shift={(196,210)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da0491508391303197] 
\draw    (160,210) -- (141.41,228.59) ;
\draw [shift={(140,230)}, rotate = 315] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da4424478744689285] 
\draw    (170,30) -- (228.8,108.4) ;
\draw [shift={(230,110)}, rotate = 233.13] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da9341165159771404] 
\draw [line width=1.5]    (316.56,170) -- (316.56,247) ;
\draw [shift={(316.56,250)}, rotate = 270] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Straight Lines [id:da4700324062294746] 
\draw [line width=1.5]    (316.56,170) -- (374.76,247.6) ;
\draw [shift={(376.56,250)}, rotate = 233.13] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Straight Lines [id:da6206056974950449] 
\draw [line width=1.5]    (316.56,170) -- (316.56,53) ;
\draw [shift={(316.56,50)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Shape: Circle [id:dp9278618893074794] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (310,170) .. controls (310,166.38) and (312.94,163.44) .. (316.56,163.44) .. controls (320.19,163.44) and (323.13,166.38) .. (323.13,170) .. controls (323.13,173.62) and (320.19,176.56) .. (316.56,176.56) .. controls (312.94,176.56) and (310,173.62) .. (310,170) -- cycle ;
%Straight Lines [id:da05847350311292765] 
\draw [line width=1.5]    (316.56,170) -- (344.07,151.66) ;
\draw [shift={(346.56,150)}, rotate = 146.31] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Shape: Arc [id:dp5580370574812169] 
\draw  [draw opacity=0] (423.67,179.66) .. controls (422.48,179.88) and (421.25,180) .. (420,180) .. controls (408.95,180) and (400,171.05) .. (400,160) .. controls (400,148.95) and (408.95,140) .. (420,140) .. controls (431.05,140) and (440,148.95) .. (440,160) .. controls (440,160.15) and (440,160.29) .. (440,160.44) -- (420,160) -- cycle ; \draw   (423.67,179.66) .. controls (422.48,179.88) and (421.25,180) .. (420,180) .. controls (408.95,180) and (400,171.05) .. (400,160) .. controls (400,148.95) and (408.95,140) .. (420,140) .. controls (431.05,140) and (440,148.95) .. (440,160) .. controls (440,160.15) and (440,160.29) .. (440,160.44) ;  
\draw   (415,175) -- (425,180) -- (415,185) ;

% Text Node
\draw (197,200.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (163,152.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (127,222.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (203,52.4) node [anchor=north west][inner sep=0.75pt]    {$\vec{V}_{\infty }$};
% Text Node
\draw (311,250.4) node [anchor=north west][inner sep=0.75pt]    {$F_{g}$};
% Text Node
\draw (371,250.4) node [anchor=north west][inner sep=0.75pt]    {$F_{D}$};
% Text Node
\draw (301,30.4) node [anchor=north west][inner sep=0.75pt]    {$F_{T}$};
% Text Node
\draw (351,142.4) node [anchor=north west][inner sep=0.75pt]    {$F_{L}$};
% Text Node
\draw (431,172.4) node [anchor=north west][inner sep=0.75pt]    {$M_{A}$};
% Text Node
\draw (291,162.4) node [anchor=north west][inner sep=0.75pt]    {$A$};


\end{tikzpicture}

    \caption{3-DoF Forces on a Body}
    \label{fig:3 DoF Forces}
\end{figure}
\newglossaryentry{angle of attack}
{
    name=angle of attack,
    first={\textit{angle of attack}},
    description={The angle of offset of the freestream velocity with the $\hat{X}$/$\hat{b}_1$, or longitudinal axis, of the vehicle. This is often denoted with the Greek letter $\alpha$}
}
As compared to 1-\gls{dof} case, we have three new quantities that are present. The first of these is $\vec{V}_{\infty}$, the freestream airflow vector, being shown on the diagram.\footnote{\gls{freestream} velocity  is drawn in the direction of incoming air by convention. However, for calculations, we will use the convention that  is the direction of the velocity of the vehicle (opposite sign to drawing).} This is represented diagrammatically because it no longer must be along the $\hat{y}$ direction. When we have an angle between the nose (the direction through which the thrust force points in Figure 2) and the \gls{freestream} velocity, we refer to this as an \gls{angle of attack}. This \gls{angle of attack} is often denoted with the letter $\alpha$. We will discuss \gls{angle of attack} and its effects more in section 4. For now, we simply need to understand how to calculate  given the vector through the nose and the \gls{freestream} velocity vector.

To do this, we use the fact that the dot product is related to the cosine of the angle between the vectors. Denoting the vector through the nose of the rocket , we can find the \gls{angle of attack} as:
\begin{equation}\label{eq:alpha}
    \alpha=cos^{-1}\left(\frac{\hat{X}\cdot \vec{V}_{\infty}}{||\hat{X}||\ ||\vec{V}_{\infty}||}\right)
\end{equation}

The next new quantity is $F_L$, the force of lift. The force of lift is always perpendicular in direction to $\vec{V}_{\infty}$. Knowing this, we can find the direction of the force of lift as:
\begin{equation}\label{eq:Lift}
    \hat{L}=\frac{(\hat{V}_{\infty} \times \hat{X}) \times \hat{V}_{\infty}}{||(\hat{V}_{\infty} \times \hat{X}) \times \hat{V}_{\infty}||}
\end{equation}
Here, the cross product is used because it generates a vector orthogonal to the two input vectors. This is exactly the property that we need when defining lift.

For the sake of completeness, we should also note that the force of drag lies opposite the direction of . This is much simpler to calculate, and looks like:
\begin{equation}\label{eq:drag}
\hat{D}=\frac{-\hat{V}_{\infty}}{||\hat{V}_{\infty}||}
\end{equation}

The last force directions to define are the direction of thrust and the direction of gravity. Luckily, these are easily defined because they point directly along basis vectors.\footnote{We assume here that there is no misalignment in the thrust vector and it is coincident with the  vector.} The force of gravity is defined with respect to the inertial reference frame and is defined in \eqref{eq:Fg}. The force of thrust is defined with respect to the vector pointing through the nose, $\hat{X}$, and is shown in \eqref{eq:Ft}:
\begin{equation}\label{eq:Fg}
    \vec{F}_g=-mg\cdot \hat{y}
\end{equation}
\begin{equation}\label{eq:Ft}
    \vec{F}_T=F_T\cdot \hat{X}
\end{equation}
\subsection{Moments}\label{sec:moments}
The last new quantity is the moment about point A, denoted $M_A$. For now, we will simply note that for an arbitrary selection of point A, we will have a rotational moment that is generated because the forces on the body do not necessarily act through point A, even if it is the center of mass (see section 4 for more details). In Figure\ref{fig:3 DoF Forces}, we have drawn all of the forces acting through a single point for simplicity, but this is not generally the case.

For our rocket modeling, it is generally assumed that gravity and thrust act about the center of gravity, and the aerodynamic forces about the center of pressure (more on this in 4.1.1).

We will show how to compute this moment if the location of the center of gravity and the center of pressure is known. To show this, we will briefly return the 2D case for illustration, but keep in mind that this concept is extensible in 3D. We show this in Figure \ref{fig:Moments}.

\begin{figure}
    \centering
    
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Rectangle [id:dp16059631350753278] 
\draw   (224,90) -- (364,90) -- (364,230) -- (224,230) -- cycle ;
%Shape: Circle [id:dp26152316559967836] 
\draw   (284,160) .. controls (284,154.48) and (288.48,150) .. (294,150) .. controls (299.52,150) and (304,154.48) .. (304,160) .. controls (304,165.52) and (299.52,170) .. (294,170) .. controls (288.48,170) and (284,165.52) .. (284,160) -- cycle ;
%Straight Lines [id:da4396178512453982] 
\draw [line width=1.5]    (294,150) -- (294,33) ;
\draw [shift={(294,30)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Straight Lines [id:da6367078669315451] 
\draw [line width=1.5]    (294,170) -- (294,247) ;
\draw [shift={(294,250)}, rotate = 270] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Shape: Circle [id:dp9868324677149697] 
\draw  [color={rgb, 255:red, 74; green, 144; blue, 226 }  ,draw opacity=1 ][fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (334,160) .. controls (334,154.48) and (338.48,150) .. (344,150) .. controls (349.52,150) and (354,154.48) .. (354,160) .. controls (354,165.52) and (349.52,170) .. (344,170) .. controls (338.48,170) and (334,165.52) .. (334,160) -- cycle ;
%Straight Lines [id:da08375154983020605] 
\draw [line width=1.5]    (344,160) -- (371.5,141.66) ;
\draw [shift={(374,140)}, rotate = 146.31] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Straight Lines [id:da9997269035553926] 
\draw [line width=1.5]    (344,160) -- (402.2,237.6) ;
\draw [shift={(404,240)}, rotate = 233.13] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
%Straight Lines [id:da3915949331033487] 
\draw [color={rgb, 255:red, 128; green, 128; blue, 128 }  ,draw opacity=1 ]   (344,160) -- (432.34,218.89) ;
\draw [shift={(434,220)}, rotate = 213.69] [color={rgb, 255:red, 128; green, 128; blue, 128 }  ,draw opacity=1 ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Circle [id:dp6233406826761347] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (342.33,160) .. controls (342.33,159.08) and (343.08,158.33) .. (344,158.33) .. controls (344.92,158.33) and (345.67,159.08) .. (345.67,160) .. controls (345.67,160.92) and (344.92,161.67) .. (344,161.67) .. controls (343.08,161.67) and (342.33,160.92) .. (342.33,160) -- cycle ;
%Shape: Pie [id:dp5263153723129019] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (294,150) .. controls (294,150) and (294,150) .. (294,150) .. controls (299.52,150) and (304,154.48) .. (304,160) -- (294,160) -- cycle ;
%Shape: Pie [id:dp03519524739615432] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (294,170) .. controls (294,170) and (294,170) .. (294,170) .. controls (294,170) and (294,170) .. (294,170) .. controls (288.48,170) and (284,165.52) .. (284,160) -- (294,160) -- cycle ;
%Straight Lines [id:da5638933773253405] 
\draw [color={rgb, 255:red, 208; green, 2; blue, 27 }  ,draw opacity=1 ][line width=1.5]    (294,160) -- (340,160) ;
\draw [shift={(344,160)}, rotate = 180] [fill={rgb, 255:red, 208; green, 2; blue, 27 }  ,fill opacity=1 ][line width=0.08]  [draw opacity=0] (9.29,-4.46) -- (0,0) -- (9.29,4.46) -- cycle    ;
%Shape: Circle [id:dp854204209250383] 
\draw   (444,50) .. controls (444,44.48) and (448.48,40) .. (454,40) .. controls (459.52,40) and (464,44.48) .. (464,50) .. controls (464,55.52) and (459.52,60) .. (454,60) .. controls (448.48,60) and (444,55.52) .. (444,50) -- cycle ;
%Shape: Pie [id:dp5370740069872785] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (454,60) .. controls (454,60) and (454,60) .. (454,60) .. controls (454,60) and (454,60) .. (454,60) .. controls (448.48,60) and (444,55.52) .. (444,50) -- (454,50) -- cycle ;
%Shape: Pie [id:dp7640770799900009] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (454,40) .. controls (454,40) and (454,40) .. (454,40) .. controls (459.52,40) and (464,44.48) .. (464,50) -- (454,50) -- cycle ;
%Shape: Circle [id:dp281241699306923] 
\draw  [color={rgb, 255:red, 74; green, 144; blue, 226 }  ,draw opacity=1 ][fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (444,90) .. controls (444,84.48) and (448.48,80) .. (454,80) .. controls (459.52,80) and (464,84.48) .. (464,90) .. controls (464,95.52) and (459.52,100) .. (454,100) .. controls (448.48,100) and (444,95.52) .. (444,90) -- cycle ;
%Straight Lines [id:da2704614420307284] 
\draw    (130,190) -- (130,152) ;
\draw [shift={(130,150)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da24091737468013485] 
\draw    (130,190) -- (164,190) ;
\draw [shift={(166,190)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Shape: Arc [id:dp6249807559731687] 
\draw  [draw opacity=0] (130,200) .. controls (130,200) and (130,200) .. (130,200) .. controls (130,200) and (130,200) .. (130,200) .. controls (124.48,200) and (120,195.52) .. (120,190) .. controls (120,184.48) and (124.48,180) .. (130,180) .. controls (135.52,180) and (140,184.48) .. (140,190) -- (130,190) -- cycle ; \draw   (130,200) .. controls (130,200) and (130,200) .. (130,200) .. controls (130,200) and (130,200) .. (130,200) .. controls (124.48,200) and (120,195.52) .. (120,190) .. controls (120,184.48) and (124.48,180) .. (130,180) .. controls (135.52,180) and (140,184.48) .. (140,190) ;  
\draw   (125,195) .. controls (126.67,197.78) and (128.33,199.44) .. (130,200) .. controls (128.33,200.56) and (126.67,202.22) .. (125,205) ;

% Text Node
\draw (284,10.4) node [anchor=north west][inner sep=0.75pt]    {$F_{T}$};
% Text Node
\draw (285,252.4) node [anchor=north west][inner sep=0.75pt]    {$F_{g}$};
% Text Node
\draw (374,132.4) node [anchor=north west][inner sep=0.75pt]    {$F_{L}$};
% Text Node
\draw (405,242.4) node [anchor=north west][inner sep=0.75pt]    {$F_{D}$};
% Text Node
\draw (435,212.4) node [anchor=north west][inner sep=0.75pt]    {$F_{R}$};
% Text Node
\draw (305,130.4) node [anchor=north west][inner sep=0.75pt]    {$\stackrel {\rightharpoonup}{r}_{ma}$};
% Text Node
\draw (473,42.4) node [anchor=north west][inner sep=0.75pt]    {$\stackrel {\rightharpoonup}{r}_{cg}$};
% Text Node
\draw (475,80.4) node [anchor=north west][inner sep=0.75pt]    {$\stackrel {\rightharpoonup}{r}_{cp}$};
% Text Node
\draw (167,180.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (133,132.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (132,203.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};


\end{tikzpicture}

    \caption{Moment Demonstration}
    \label{fig:Moments}
\end{figure}
In Figure \ref{fig:Moments} we include a few new symbols. All force magnitudes, however, are equivalent to what we show in Figure 2 (with the assumption that they lie in the x-y plane for this example). We denote the location of the center of gravity as $\vec{r}_{cg}$ and the location of the center of pressure as $\vec{r}_{cp}$. The difference between $\vec{r}_{cg}$ and $\vec{r}_{cp}$ is denoted as $\vec{r}_{ma}$. We refer to this as the moment arm of the aerodynamic forces. It should be noted that all of locations are tridimensional vectors. 

We also define a new vector, $F_R$, the resultant aerodynamic vector, which is the vector sum of $F_D$ and $F_L$. Because free rotations occur about the center of mass, it is most helpful to calculate our final moment from this location. To do so, we use the moment equation:
$$M=\vec{r}\times \vec{F}_R$$
\newacronym{rhr}{RHR}{right hand rule}
We note that the direction of this moment is in the $-\hat{z}$ direction from the \gls{rhr}. If we assume that our forces are planar, this moment will generate a rotation about a single axis. This effectively makes our model into a 4-\gls{dof}.

One thing to note is that some quantities are more easily defined with respect to vectors that are defined with respect to the vehicle (which we will call the \textit{body frame}), such as the vector $\hat{X}$. As seen in Equation \eqref{eq:alpha} and \eqref{eq:Lift}, we often want to use these vectors in the body frame for computation. As such, we will need a method in which we can convert between the body and inertial frames. This conversion between frames is explored in section \ref{sec:Frame of Reference}. We should also note that our moments will be in this body frame as well, which turns out to be especially useful in Section \ref{Euler Rotation Equations}.

The last thing that we note in this section is that our forces are moments are coupled. This means that the aerodynamic forces are a function of the orientation of the vehicle, so the moments and forces must be solved as a system.
\subsection{State Vector}
As a last note for this section, we will briefly discuss the concept of a \gls{state vector}. The \gls{state vector} is a column vector that contains information on the current state of our system. In the example of our 4-\gls{dof}, we will include the position, velocity, rotation, and rotation rate of the system in the \gls{state vector}. This would look like:
$$\vec{X}=\begin{bmatrix}
    x\\y\\z\\\dot{x}\\\dot{y}\\\dot{z}\\\theta\\\dot{\theta}
\end{bmatrix}$$
It is also useful to define the derivative of our \gls{state vector}, which would just be the derivative of each of its elements. This is expressed as
$$\dot{\textbf{X}}=\begin{bmatrix}
    \dot{x}\\\dot{y}\\\dot{z}\\\ddot{x}\\\ddot{y}\\\ddot{z}\\\dot{\theta}\\\ddot{\theta}
\end{bmatrix}$$
For the sake of compactness, these vectors are generally not written in their full form. In this text, we will often refer to a \gls{state vector} as just $\vec{X}$. Note that we also use the vector $\hat{X}$ to denote a unit vector in the body frame, so the difference in the hat becomes an important distinction here.

\chapter{Attitude Dynamics}\label{sec:attitude dynamics}
\begin{chapquote}{Lord Kelvin, 1892}
''Quaternions came from Hamilton after his really good work had been done; and, though beautifully ingenious, have been an unmixed evil to those who have touched them in any way, including Clerk Maxwell.''
\end{chapquote}
Attitude Dynamics is the math describing the orientation of a vehicle in space as the result of applied moments. Relying heavily on advanced mathematics, this concept is naturally more difficult to grasp. However, we hope that, here more than anywhere, our centralization of all basic necessary information to understand the topic eases the pain a little.\footnote{For further understanding, see section 8 for more provided materials. } In fact, don’t be afraid to reach out to either Hudson Reynolds (@Hudson Reynolds) or I (@Preston Wright) on Slack with questions! A final note on the section: many of the derivations closely follow both the process and notation of resources which will become available to you throughout your time here at Purdue AAE. These are the AAE340 class script by Professors Frueh and Longuski, and the AAE590 Attitude Dynamics and Control script by Professor Frueh.
\section{Frame of Reference}\label{sec:Frame of Reference}
Before attempting to describe the orientation of any random body in space, we must first discuss how and why this is possible. A frame of reference is an \textit{orthonormal} set within three-dimensional space. The orthonormal nature of the basis vectors that create every frame of reference allows for any other vector in three-dimensional space to be described as a linear combination of those three basis vectors (hence why we call it a basis for 3-space). This tool becomes incredibly useful within the study of Newtonian and Attitude Dynamics, as every \gls{state vector} can be broken down into three set “scalar” directions. Naturally, the question arises of how we determine which set directions to utilize, and so we will be discussing a few frames of reference critical to the creation of a 6-\gls{dof} and Aerospace engineering as a whole.
\subsection{The Inertial Frame}
The first and most important frame of reference is the \textit{inertial frame}. Typically denoted by $e$ or $i$ (we avoid $i$ in this case because of our heavy use of complex numbers), or in our case $(\hat{x},\hat{y},\hat{z})$, this motionless frame is the one that allows for the use of Newton’s second law in the first place, as the frame itself has “zero” translational and rotational movement.\footnote{An inertial frame can have some constant velocity and still be inertial. Of course, the earth has some velocity around the sun and with respect to the distant stars which we can approximate as constant for our time scales and thus ignore.} We say “zero” as this motion must be negligible in relation to the vehicle of interest. For example, this specific 6-\gls{dof} sets the inertial frame to be anchored within the Earth on the launch pad. And while we are well aware the Earth is moving and rotating through space at a non-zero rate, this motion is negligible relative to the motion of our vehicle which remains close to Earth within the atmosphere for a short period of time. Therefore, we can assume that the Earth acts appropriately as an inertial frame of reference, and Newton’s second law is valid for this frame. 

Returning to the specific example of a 6-\gls{dof}, the directions you set your basis vectors to point in are mostly left to the coder’s discretion. If your chosen directions retain the orthonormal nature of a frame of reference, as well as obeying \textit{the right-hand rule}, the choice is all yours. Within the example we are following, our inertial frame’s origin is anchored within the launch pad as previously stated. The first inertial basis vector points up perpendicular to the Earth’s surface, the second inertial basis vector points due East, while the third inertial basis vector follows the right-hand rule and points due North. An image for quick reference is provided below:

\begin{figure}[H]
\centering
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,356); %set diagram left start at 0, and has height of 356

%Shape: Axis 2D [id:dp4662897481397581] 
\draw  (244,205.18) -- (448.8,205.18)(264.48,52) -- (264.48,222.2) (441.8,200.18) -- (448.8,205.18) -- (441.8,210.18) (259.48,59) -- (264.48,52) -- (269.48,59)  ;
%Straight Lines [id:da8652713079639678] 
\draw    (278.8,190.2) -- (174.38,299.55) ;
\draw [shift={(173,301)}, rotate = 313.68] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Circle [id:dp9817397826908267] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (259.08,205.18) .. controls (259.08,202.2) and (261.5,199.78) .. (264.48,199.78) .. controls (267.46,199.78) and (269.88,202.2) .. (269.88,205.18) .. controls (269.88,208.16) and (267.46,210.58) .. (264.48,210.58) .. controls (261.5,210.58) and (259.08,208.16) .. (259.08,205.18) -- cycle ;

% Text Node
\draw (242,9) node [anchor=north west][inner sep=0.75pt]   [align=left] {Upward};
% Text Node
\draw (253,27.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} ,\hat{e}_{1}$};
% Text Node
\draw (154,300.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y} ,\hat{e}_{2}$};
% Text Node
\draw (151,325) node [anchor=north west][inner sep=0.75pt]   [align=left] {East};
% Text Node
\draw (453,187.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} ,\hat{e}_{3}$};
% Text Node
\draw (448,211) node [anchor=north west][inner sep=0.75pt]   [align=left] {North};
% Text Node
\draw (271.89,208.15) node [anchor=north west][inner sep=0.75pt]  [rotate=-0.04] [align=left] {Launchpad};


\end{tikzpicture}
    \caption{Inertial Frame Convention}
    \label{fig:InertialFrame}
\end{figure}

\subsection{The Body Frame}
The second most important frame of reference is the \textit{body frame}. Typically denoted by $b$, or in our case $(\hat{X},\hat{Y},\hat{Z})$, this frame of reference is always anchored at some point in the vehicle and allows us to describe the \gls{state vector} in relation to the vehicle itself. This frame is moving and rotating with respect to the inertial frame. For every body frame you create – from a frame for the entire vehicle to a frame for a small electronic part – you want simplicity. This means that in aerospace, it is necessary for a general body frame to have a basis vector pointing along the longitudinal axis of the vehicle, as well as one out a wing. In addition, it means at a zero angle of rotation, every basis vector of the body frame is parallel to the corresponding basis vector in the inertial frame. This is imperative to rotational dynamics, as the offset of each basis vector in the body frame will correspond to the pitch, yaw, and roll of the vehicle. But more on that later.

\begin{figure}[H]
\centering
    
\includegraphics[width=\linewidth]{BodyFrame.png}
    \caption{Typical Body Frame Orientation}
    \label{fig:BodyFrameTypical}
\end{figure}

For our current model, the body frame of our 6-\gls{dof} has its origin in the nose of the vehicle. It has the first body basis vector, $\hat{X}$, pointing up along the longitudinal axis of the rocket following standard convention. The second basis vector, $\hat{Y}$, points right due East when on the launch pad, and the third, $\hat{Z}$, points due North on the launch pad. We use the cardinal directions of the launchpad as not only are there no conventional wings on the rocket, but it allows body frame to be defined parallel to the corresponding inertial frame basis vectors. Note that they won’t remain pointing in these directions as the rocket moves through space, and they may not even begin parallel to the inertial axis to begin with if the rocket launches from a tilt.

\begin{figure}[H]
\centering
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,408); %set diagram left start at 0, and has height of 408

%Shape: Can [id:dp7760621042562805] 
\draw   (351,111) -- (351,268) .. controls (351,276.28) and (337.57,283) .. (321,283) .. controls (304.43,283) and (291,276.28) .. (291,268) -- (291,111) .. controls (291,102.72) and (304.43,96) .. (321,96) .. controls (337.57,96) and (351,102.72) .. (351,111) .. controls (351,119.28) and (337.57,126) .. (321,126) .. controls (304.43,126) and (291,119.28) .. (291,111) ;
%Shape: Axis 2D [id:dp16563267347652144] 
\draw  (310,183.2) -- (410,183.2)(320,50) -- (320,198) (403,178.2) -- (410,183.2) -- (403,188.2) (315,57) -- (320,50) -- (325,57)  ;
%Straight Lines [id:da8489216589462083] 
\draw    (328.8,173) -- (270.21,250.41) ;
\draw [shift={(269,252)}, rotate = 307.12] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (304,3.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{X} /\hat{b}_{1}$};
% Text Node
\draw (238,248.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{Y} /\hat{b}_{2}$};
% Text Node
\draw (414,167.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{Z} ,\hat{b}_{3}$};
% Text Node
\draw (297,222) node [anchor=north west][inner sep=0.75pt]   [align=left] {Rocket};
% Text Node
\draw (292,29.4) node [anchor=north west][inner sep=0.75pt]    {$\phi -axis$};
% Text Node
\draw (229,273.4) node [anchor=north west][inner sep=0.75pt]    {$\theta -axis$};
% Text Node
\draw (406,192.4) node [anchor=north west][inner sep=0.75pt]    {$\psi -axis$};

\end{tikzpicture}
    \caption{Body Frame Convention of our Rocket}
    \label{fig:BodyFrameRocket}
\end{figure}


%% Another Figure
\subsection{The Wind Frame}
The last and by far least important frame of reference is the \textit{wind frame.} This frame of reference, like the body frame, is always anchored at some point in the vehicle. Also like the body frame, it moves and rotates with the vehicle and allows for a new way of describing the \gls{state vector}. Unlike the body frame, the most important definition is not along the longitudinal axis of the vehicle. As indicated by its name, the necessary orientation of a basis vector points in the direction of the free stream velocity. Relating this to the body frame, this translates to an offset from the body frame by the \gls{angle of attack} and sideslip. This frame is often useful for aircraft, but we do not use it explicitly in our 6-\gls{dof}. The wind frame itself is in fact skipped over during wind calculations, as the \gls{angle of attack} and imparted forces/moments are calculated directly onto the body frame. So as this isn’t as useful as the other two reference frames, we won’t elaborate on this frame any further, and it won’t be shown as much in our example 6-\gls{dof}.

\section{Euler Rotation Equations}\label{Euler Rotation Equations}
\newglossaryentry{moment of inertia}
{
    name=moment of inertia,
    first={\textit{moment of inertia}},
    description={A measure of its resistance to rotational acceleration. It is in essence, the rotational analogue of mass. Often denoted with the letter $I$}
}

In Section \ref{sec:moments} we have explored the moments that are created when a force acts at a point that is not through the center of mass.

In analogy to Newton's 2nd Law of motion, there is an equally important relationship for rotational dynamics. This equation is known as Euler's 2nd Law:
\begin{equation}\label{eq:Euler 2nd Law}
    \vec{M}^o=^{i}\frac{d\vec{H}^o}{dt}
\end{equation}
This equation reads as 'The moment about point $O$ is the inertial time derivative of the angular momentum, H, about point $O$. The superscript $i$ refers to the fact that this derivative must be taken in the inertial frame.

We also have the relationship between angular momentum, $H$, and the \gls{moment of inertia}, $I$, for an rigid body that you have likely seen in physics classes:
\begin{equation}\label{eq:Iw}
    {}^i\vec{H}={}^iI\vec{\omega}
\end{equation}
You will notice that our moment of inertia here is defined with respect to the inertial frame. As a result, when our body changes orientation, the moment of inertia may also change!

Often however, it is more helpful to define this moment of inertia in terms of our body frame. We will go through this derivation of the moment of inertia below.
\subsection{Moment of Inertia and Inertia Tensor}\label{moment of inertia}
The moment of inertia of a body is a measure of its resistance to rotational acceleration. It is in essence, the rotational analogue of mass (mass is a measure of resistance to linear acceleration, by the same line of reasoning).

Since we need the moment of inertia to describe our relationship for angular momentum in \eqref{eq:Iw}, it is useful for us to see its derivation here.

We can start by showing that the mass of a region can be found by integrating the density over it's volume. Mathematically, we show this as:
$$\iiint\limits_V{\rho}{dV}$$
Similarly, we know that the moment of inertia of a particle is $mr^2$, which is it's mass multiplied with the length of the moment arm, $r$, squared. This is often referred to as the 'second moment' of mass. By integrating this second moment, we have:
$$\iiint\limits_V{\rho}{r^2}{dV}$$
It is useful to define the moment of inertia along each direction, though. We can rewrite $r$ in terms of $x$, $y$, and $z$ for each of the component directions:
\begin{gather}
    I_{xx}=\iiint\limits_V{\rho}{\left(y^2+z^2\right)}{dV}\\
    I_{yy}=\iiint\limits_V{\rho}{\left(x^2+z^2\right)}{dV}\\
    I_{zz}=\iiint\limits_V{\rho}{\left(x^2+y^2\right)}{dV}
\end{gather}
For our rocket, we will find that these are the only quantities that we need to define. However, in general, we also have three more quantities, which are called the product of inertia. This is defined by the product of two of our elements, such as $xy$. This will have the same dimensions as the quantity $r^2$, so it can be applied in a similar way to the moment of inertia. The product of inertia is defined as follows:
\begin{gather}
    I_{xy}=I_{yx}\iiint\limits_V{-xy\rho}{dV}\\
    I_{xz}=I_{zx}\iiint\limits_V{-xz\rho}{dV}\\
    I_{yz}=I_{zy}\iiint\limits_V{-yz\rho}{dV}
\end{gather}
For our rocket, because of the symmetry about the $\hat{X}$ axis, these quantities go to zero. However, for future implementations that may include fuel slosh and asymmetries, the products of inertia may be non-zero!
\newglossaryentry{inertia tensor}
{
    name={inertia tensor},
    first=\textit{inertia tensor},
    description={A matrix that describes the moment of inertia along each of the axes of a body. This matrix, often denoted $I$, transforms the angular velocity, $\omega$ into an angular momentum, $H$.}
}
We express our \gls{inertia tensor}, denoted $I$, as the $3\times3$ matrix which contains the moments and products of inertia.
$$I=\begin{bmatrix}
    I_{xx}&I_{xy}&I_{xz}\\
    I_{yx}&I_{yy}&I_{yz}\\
    I_{zx}&I_{zy}&I_{zz}
\end{bmatrix}$$
For our rocket, we get the simplification that:
$$I=\begin{bmatrix}
    I_{xx}&0&0\\
    0&I_{yy}&0\\
    0&0&I_{zz}
\end{bmatrix}$$
\newglossaryentry{principle axes}
{
    name={principle axes},
    first=\textit{principle axes},
    description={The axes defined such that the products of inertia for a body are zero. These axes are the values that solve the eigenvalue problem $I\vec{\omega}=I^*\vec{\omega}$}
}
\newacronym{pmoi}{PMOI}{principle moment of inertia}
In fact, we can always find axes such that the products of inertia are zero. These are called the \gls{principle axes} and are important in other applications, such as structures \cite{baker_statics_2020}. For our rocket, it just happens that these \gls{principle axes} are the ones we have chosen to define as our body frame. The moment of inertia along these principle axes are solutions to the eigenvalue problem $I\vec{\omega}=I^*\vec{\omega}$, where $I^*$ is a scalar. Essentially, we are finding a matrix $I$ such that the output is just a scalar multiple of the input, $\omega$. We can see that having this property will greatly simplify our results. This is another reason why we like to perform many calculations in the body frame.

Using the inertia tensor, a matrix form of \eqref{eq:Iw}  is written as:
\begin{equation}\label{eq:IwVec}
    \vec{H}=I\vec{\omega}
\end{equation}
In the simplification using the principle axes, we often refer to the terms $I_{xx}$, $I_{yy}$, and $I_{zz}$ simply as $I_x$, $I_y$, and $I_z$. There are called the \glspl{pmoi}.
\subsection{Rotations in the Body Frame}\label{sec:rotations in the body frame}
Now that we have defined our inertia tensor in the body frame, it is useful to reexamine \eqref{eq:Euler 2nd Law} and \eqref{eq:Iw} to express them in terms of the body frame.
\newacronym{bke}{BKE}{Basic Kinematic Equation}
We can express equation \eqref{eq:Euler 2nd Law} in terms of the body frame using the \gls{bke}. We write this as:
\begin{equation}\label{eq:bke}
{}^i\frac{dH^o}{dt}={}^b\frac{dH^o}{dt}+{}^e\vec{\omega}^b\times H^o
\end{equation}
In the case of principle axes, \eqref{eq:IwVec} can be simplified to yield:
$${}^iH^o=I_x\omega_x\hat{b}_1+I_y\omega_y\hat{b}_2+I_z\omega_z\hat{b}_3$$
Plugging this result into \eqref{eq:bke}, we get the following:
$${}^i\frac{dH^o}{dt}={}^b\frac{d}{dt}\left(I_x\omega_x\hat{b}_1+I_y\omega_y\hat{b}_2+I_z\omega_z\hat{b}_3\right)+{}^e\vec{\omega}^b\times \left(I_x\omega_x\hat{b}_1+I_y\omega_y\hat{b}_2+I_z\omega_z\hat{b}_3\right)$$
Where ${}^e\vec{\omega}^b$ is $\omega_x\hat{b}_1+\omega_y\hat{b}_2+\omega_z\hat{b}_3$. The algebraic manipulation and vector math here is left as an exercise for the reader. Collecting the final terms, our final expression is:
$${}^iH^o=\left[I_x\dot{\omega}_x+\left(I_z-I_y\right)\right]\hat{b}_1+\left[I_y\dot{\omega}_y+\left(I_x-I_z\right)\right]\hat{b}_2+\left[I_z\dot{\omega}_z+\left(I_y-I_x\right)\right]\hat{b}_3$$
Equating this with the moments in the body frame that were found in \ref{sec:moments} as ${}^bM^o=M_x\hat{b}_1+M_y\hat{b}_2+M_z\hat{b}_3$, we arrive at the final form of our equations for Euler rotations\footnote{Very observant readers may notice that this form of the equation is technically \textit{slightly} incorrect, since our center of rotation, $O$, will change throughout the flight as the center of mass changes position. Thus, we will have some small effects that are not accounted for in this equation. For our purposes, these are ignored for simplicity. However, a more general approach that implements this may be used in the future if slosh modelling is implemented.}:
\begin{gather}\label{eq: moment equations}
    M_x=I_x\dot{\omega}_x+\left(I_z-I_y\right)\omega_y\omega_z\\
    M_y=I_y\dot{\omega}_y+\left(I_x-I_z\right)\omega_z\omega_x\\
    M_z=I_z\dot{\omega}_z+\left(I_y-I_x\right)\omega_y\omega_x
\end{gather}
We can rearrange this to a form that is more useful for us (although somewhat less sightly), putting the unknown $\dot\omega$ (we also refer to this quantity as the angular acceleration, $\vec{\alpha}$) quantities alone:
\begin{gather}\label{eq: moment eq 2}
    \dot{\omega}_x=\frac{M_x-\left(I_z-I_y\right)\omega_y\omega_z}{I_x}\\
    \dot{\omega}_y=\frac{M_y-\left(I_x-I_z\right)\omega_z\omega_x}{I_y}\\
    \dot{\omega}_z=\frac{M_z-\left(I_y-I_x\right)\omega_y\omega_x}{I_z}
\end{gather}
These sets of equations are especially powerful because they allows us to numerically integrate the angular velocity. Our moments can be found using Newtonian dynamics and the \glspl{pmoi} are quantities that are easily found using the integrals described above in section \ref{moment of inertia}. We will use these angular velocity derivatives extensively in sections \ref{sec:DescribeEulerRates} and \ref{sec: quaternion rates} to describe the time rate of change of the attitude of the rocket.
\section{2-D Rotations}\label{sec:2D Rotations}
Before moving into rotations in 3-dimensional space, let’s start simple. Say you have an arrow drawn on a piece of paper, and you twist the paper about the origin of that arrow through an angle $\theta$. While you could measure the new vector’s components directly to describe your new arrow, we want a more generalized way to find a new vector for any rotation. 
\subsection{Real Rotations}
\newglossaryentry{rhrRot}{
name={right hand rule (for rotations)},
first = \textit{right hand rule (for rotations)},
description = {This right hand rule helps determine the positive direction of rotation about an axis. Simpler than the previous right hand rule, you take your right hand and point your thumb in the direction of the axis you want to rotate about. Pretending to grasp the vector, the direction your fingers curl denotes the direction of positive rotation}
}
We will start the problem by defining our notation. We will utilize Cartesian coordinates with the positive $\hat{x}$ direction pointing to the right, $\hat{y}$ up, and $\hat{z}$ coming out of the page. Using this convention, a positive $\theta$ rotation is counterclockwise about the origin by use of the \gls{rhrRot}. We show an example of such a rotation in \ref{fig:2DRotation}:
%add glossary entry
\begin{figure}[H]
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Axis 2D [id:dp2369017718792994] 
\draw  (274,169.56) -- (408.8,169.56)(287.48,48.6) -- (287.48,183) (401.8,164.56) -- (408.8,169.56) -- (401.8,174.56) (282.48,55.6) -- (287.48,48.6) -- (292.48,55.6)  ;
%Straight Lines [id:da6414021669220791] 
\draw [color={rgb, 255:red, 239; green, 11; blue, 11 }  ,draw opacity=1 ][line width=1.5]    (287.48,169.56) -- (383.8,169.6) ;
\draw [shift={(386.8,169.6)}, rotate = 180.02] [color={rgb, 255:red, 239; green, 11; blue, 11 }  ,draw opacity=1 ][line width=1.5]    (11.37,-3.42) .. controls (7.23,-1.45) and (3.44,-0.31) .. (0,0) .. controls (3.44,0.31) and (7.23,1.45) .. (11.37,3.42)   ;
%Straight Lines [id:da18731248462614536] 
\draw [color={rgb, 255:red, 215; green, 23; blue, 23 }  ,draw opacity=1 ][line width=1.5]  [dash pattern={on 5.63pt off 4.5pt}]  (287.48,169.56) -- (352.78,97.82) ;
\draw [shift={(354.8,95.6)}, rotate = 132.31] [color={rgb, 255:red, 215; green, 23; blue, 23 }  ,draw opacity=1 ][line width=1.5]    (11.37,-3.42) .. controls (7.23,-1.45) and (3.44,-0.31) .. (0,0) .. controls (3.44,0.31) and (7.23,1.45) .. (11.37,3.42)   ;
%Curve Lines [id:da22919468225468265] 
\draw    (337.14,169.58) .. controls (338.68,147.4) and (329.38,138.89) .. (322.7,133.77) ;
\draw [shift={(321.14,132.58)}, rotate = 37.01] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (341,137.4) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
% Text Node
\draw (414,156.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (282,21.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};


\end{tikzpicture}
    \caption{Example of 2-D Rotation}
    \label{fig:2DRotation}
\end{figure}
% do we want to use row vector when writing inline to make it cleaner?
Using this notation, we will express vectors as either column vectors of form:
$$\begin{bmatrix}
    x\\
    y
\end{bmatrix}$$
Or using the transpose of a row vector when we write them inline, as $\begin{bmatrix}
    x&y
\end{bmatrix}^T$.

In Figure \ref{fig:2DRotation}, our solid vector can be written as a unit vector $\begin{bmatrix}
    1&0
\end{bmatrix}^T$.
\newglossaryentry{linear}{
name={linear},
first = \textit{linear},
description = {An operation that preserves vector addition and scalar multiplication. Examples of linear operators include the derivative and integral. We also explore rotations as linear mappings}
}
With knowledge of linear algebra, we can see that the rotation of the vector is just some shearing of the original vector that preserves the vector length. These operations are \gls{linear}, so it is possible to find a matrix representation of this transformation.\footnote{We may also note that the property of preserving length means that our matrix must be \textit{unitary}. \textit{Unitary} matrices also preserve the inner product. Both of these are useful properties of these matrices. From these properties, it can also be shown that this matrix must be square.}

Mathematically, we want to find a square $2\times2$ matrix $R$ – called the rotation matrix – such that: $\vec{v}_2=R\vec{v}_1$
where $\vec{v}_1$ is our original vector, and $\vec{v}_2$ is our new, rotated vector. To derive our rotation matrix $R$, we will consider two similar vectors: our $\vec{v}_1$ mentioned above, as well as a new unit vector in the $\hat{y}$-direction 
$\begin{bmatrix}
    0&1
\end{bmatrix}^T$.
For each of our unit vectors, we will use 90- and 180-degree rotations, since we know what solution we should acquire for each. Those being 
$\begin{bmatrix}
    0&1
\end{bmatrix}^T$
and 
$\begin{bmatrix}
    -1&0
\end{bmatrix}^T$
respectively for our first unit vector. 
Using the initial equation given above paired with our first 90-degree rotation, we get
$$\begin{bmatrix}
    0\\1
\end{bmatrix}=R
\begin{bmatrix}
    1\\0
\end{bmatrix}$$
Based off our knowledge of trigonometry, we already know that some combination of sines and cosines will construct our matrix $R$. With our choice of the $\hat{x}$-direction unit vector, only the first column of $R$, $\begin{bmatrix}
    r_{11}&r_{21}
\end{bmatrix}^T$, will remain after matrix multiplication. This allows for the first column of $R$ to be solved as
$$\begin{bmatrix}
    0\\1
\end{bmatrix}=
\begin{bmatrix}
    r_{11}\\r_{21}
\end{bmatrix}
$$
And with a 90 degree rotation, $r_{21}$ can be determined to be $sin(\theta)$. Moving on to the second rotation, we use the equation 
$$\begin{bmatrix}
    -1\\0
\end{bmatrix}=R
\begin{bmatrix}
    1\\0
\end{bmatrix}$$
Repeating the above process, we get:
$$\begin{bmatrix}
    -1\\0
\end{bmatrix}=
\begin{bmatrix}
    r_{11}\\sin(\theta)
\end{bmatrix}$$
At a rotation of 180 degrees, $r_{11}$ must be $cos(\theta)$. We have now completed the first column of $R$: $\begin{bmatrix}
    cos(\theta)&sin(\theta)
\end{bmatrix}^T$. If we plot the rotated unit vector as a function of $\theta$ from [0, 360) degrees, we can see that we do indeed get the unit circle.
For the $\hat{y}$ unit vector we follow an identical process and derive the second column of $R$. This derivation will be left as an exercise to the reader due to the redundancy and simplicity of the process; however, we end up with $\begin{bmatrix}
    -sin(\theta)&cos(\theta)
\end{bmatrix}^T$ as our second column vector. Putting the two together, we have our completed rotation matrix:
\begin{equation}\label{eq:2DMatrix}
    R=
    \begin{bmatrix}
        cos(\theta)&-sin(\theta)\\sin(\theta)&cos(\theta)
    \end{bmatrix}
\end{equation}
The understanding of this derivation is helpful to the understanding of the derivation of the rotation matrix in 3-dimensional space, so we will be sure to keep this process handy!

\subsection{Imaginary Rotations}\label{sec:2DImaginary}
After deriving the matrix for rotations in regular 2-dimensional space, we can use this to describe the rotation of a vector in imaginary space. These results will serve as a basis for the motivation of quaternion rotations, which will be discussed later. 

To derive an expression for complex rotations, we will start with the famous Euler's Formula:
\begin{equation}
    e^{i\theta}=cos\theta+i\cdot sin\theta
\end{equation}
A succinct and intuitive explanation of Euler's Formula is given in two 3Blue1Brown videos, shown in sources \cite{3blue1brown_eipi_2019} and \cite{3blue1brown_how_2021}. Because these videos so expertly describe this topic, we choose not to do so here. As an exercise to the reader, you can try proving this statement yourself by considering the Taylor Series expansion of $e^{ix}$ and comparing it with the Taylor Series of $sin(x)$ and $cos(x)$.

So, since the magnitude of $e^{i\theta}$ is always 1, we can parameterize the length of our vector as its magnitude, $r$.

So, we now have a complex rotator which we can describe as:
\begin{gather}
    r=cos(\theta)+isin(\theta)\\
    \text{or}\\
    r=e^{i\theta}
\end{gather}
This way, any rotation $\theta$ here is an identical to a rotation of the same above, notation and all. We are simply replacing our x-axis with our real axis, and our y-axis with our imaginary axis. From this equality, we see that multiplication of a complex number corresponding to the appropriate real and imaginary components with the above complex rotator will result in an identical rotation to the same initial conditions in 2-dimensional space. To explicitly show this, we can express our imaginary rotation as matrix multiplication for the rotation of an imaginary number $\vec{v}=v_1+v_2i$:
$$\begin{bmatrix}
    v_1'\\v_2'
\end{bmatrix}=
\begin{bmatrix}
    cos(\theta)&-sin(\theta)\\sin(\theta)&cos(\theta)
\end{bmatrix}\begin{bmatrix}
    v_1\\v_2
\end{bmatrix}$$

One thing to note here is that we can express a rotation very cleanly and naturally with complex numbers and exponentials. When we discuss quaternions in Section \ref{sec:quaternions}, these complex numbers will become increasingly important to understand.
\section{Euler Angles}

\newglossaryentry{Euler angles}
{
    name=Euler angles,
    first = {\textit{Euler angles}},
    description={A group of three scalar values used to describe the orientation of a body in space}
}

Now that we have reinforced our knowledge of reference frames and completed the simple 2-dimensional case of rotation, we are ready to move on to the significantly more complicated 3-dimensional case. There are two possible ways to describe a 3-dimensional rotation, with the first and more basic of the two being the method of \gls{Euler angles}.

Let’s say you’ve left the airport flying to Tahiti for vacation. While describing the translational motion of your aircraft is fairly simple, the orientation is much more difficult to determine. \gls{Euler angles} give a systematic method of describing that orientation with respect to an inertial frame. While systematic, there are many ways to describe the same rotation. Taking the example of your aircraft banking and climbing away from the airport, the pilot is actively controlling the aircraft using the aircraft’s control surfaces. These combine to alter the yaw, pitch, and roll of the aircraft. When mathematically describing the orientation of the aircraft as a combination of these angles, the order both does and does not matter. While keeping the same order throughout calculations is incredibly important - which we will show in subsequent sections - the initial order you choose doesn’t matter nearly as much. So long as you don’t double up on rotations (e.g. two roll movements in a row) you can choose any order of rotation you want. This means there are a total of 12 possible rotation sequences (stemming from 3 frames to choose from x 2 frames not chosen immediately prior x 2 frames not chosen immediately prior = 12 sequences). For further complexity, the generalized notation of rotation sequences and \gls{Euler angles} can be broken into two categories. The first of these are called proper Euler angles, and consist of the six rotation sequences that include a doubled rotation axis (e.g. 1-2-1, 1-3-1, 2-1-2, 2-3-2, 3-1-3, 3-2-3). The second of these groups are called Tait-Bryan angles, or Cardan angles, and consist of the six rotation sequences that include only distinct rotation axes (e.g. 1-2-3, 3-2-1, 2-1-3, 3-1-2, 1-3-2, 2-3-1). The most notable difference between the two is what becomes of the distinct rotation axes. Having distinct rotation axes allows us to pair each axis to one of pitch, yaw, or roll as seen in \ref{fig:BodyFrameTypical}, while proper Euler angles lack such a transparent connection to that more physical interpretation.

In industry and in academia, the 3-1-3 and 3-2-1 rotation orders are by far the most popular. Our example specifically uses the 3-2-1 rotation sequence due to its distinct rotation axes and subsequent transparent connection with the traditional pitch, yaw, and roll maneuvers that is characteristic of the Tait-Bryan angles. We will use this option in our mathematical approaches throughout the rest of this section.

\subsection{3-D Rotations}\label{sec:3DRotations}

Like the 2-dimensional case before, we want to find a rotation matrix $R$ such that $\vec{v_2}=R\vec{v_1}$. Starting with our visualization, let’s say you now have a book laid flat on the table in front of you. We will now move through the two previously mentioned rotation sequences with that book: 3-2-1 and 3-1-3. Each of these individual rotations will be 90 degrees in the positive direction.
We will run through each sequence parallel to each other so any differences and similarities between the two can be easily visualized. You might want to grab a similar sized shape and follow along to aid in your understanding!

\begin{figure}[H]
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,787); %set diagram left start at 0, and has height of 787

%Shape: Cube [id:dp30473314642975957] 
\draw   (63.04,117.46) -- (81.86,98.64) -- (111.98,98.64) -- (111.98,176.41) -- (93.16,195.23) -- (63.04,195.23) -- cycle ; \draw   (111.98,98.64) -- (93.16,117.46) -- (63.04,117.46) ; \draw   (93.16,117.46) -- (93.16,195.23) ;
%Shape: Axis 2D [id:dp8167558306254183] 
\draw  (79.23,147.36) -- (130.8,147.36)(84.39,78.12) -- (84.39,155.05) (123.8,142.36) -- (130.8,147.36) -- (123.8,152.36) (79.39,85.12) -- (84.39,78.12) -- (89.39,85.12)  ;
%Straight Lines [id:da314709669225804] 
\draw    (88.45,143.09) -- (52.04,189.38) ;
\draw [shift={(50.81,190.96)}, rotate = 308.18] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Cube [id:dp04065664034078331] 
\draw   (500.65,117.46) -- (519.47,98.64) -- (549.58,98.64) -- (549.58,176.41) -- (530.76,195.23) -- (500.65,195.23) -- cycle ; \draw   (549.58,98.64) -- (530.76,117.46) -- (500.65,117.46) ; \draw   (530.76,117.46) -- (530.76,195.23) ;
%Shape: Axis 2D [id:dp3732351982959756] 
\draw  (516.83,147.36) -- (568.4,147.36)(521.99,78.12) -- (521.99,155.05) (561.4,142.36) -- (568.4,147.36) -- (561.4,152.36) (516.99,85.12) -- (521.99,78.12) -- (526.99,85.12)  ;
%Straight Lines [id:da7067184304168816] 
\draw    (526.06,143.09) -- (489.65,189.38) ;
\draw [shift={(488.41,190.96)}, rotate = 308.18] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Axis 2D [id:dp7824359400520153] 
\draw  (87.65,327.45) -- (87.17,254.11)(18.07,320.48) -- (95.33,320.08) (82.22,261.14) -- (87.17,254.11) -- (92.22,261.09) (25.11,325.45) -- (18.07,320.48) -- (25.04,315.45)  ;
%Straight Lines [id:da6575365467308292] 
\draw    (91.27,315.07) -- (51.16,362.1) ;
\draw [shift={(49.87,363.62)}, rotate = 310.46] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Axis 2D [id:dp26903333318867806] 
\draw  (91.46,651.68) -- (154.33,651.68)(97.75,582.44) -- (97.75,659.37) (147.33,646.68) -- (154.33,651.68) -- (147.33,656.68) (92.75,589.44) -- (97.75,582.44) -- (102.75,589.44)  ;
%Straight Lines [id:da6349794234163055] 
\draw    (90.33,658.52) -- (150.18,590.44) ;
\draw [shift={(151.5,588.94)}, rotate = 131.32] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Cube [id:dp3079853795797345] 
\draw   (29.16,311.99) -- (47.11,294.04) -- (146.04,294.04) -- (146.04,320.03) -- (128.09,337.98) -- (29.16,337.98) -- cycle ; \draw   (146.04,294.04) -- (128.09,311.99) -- (29.16,311.99) ; \draw   (128.09,311.99) -- (128.09,337.98) ;
%Shape: Axis 2D [id:dp9811912589376763] 
\draw  (524.35,323.29) -- (524.18,249.96)(448.11,316.11) -- (532.8,315.94) (519.2,256.97) -- (524.18,249.96) -- (529.2,256.95) (455.12,321.09) -- (448.11,316.11) -- (455.1,311.09)  ;
%Straight Lines [id:da8527731941171708] 
\draw    (528.88,310.8) -- (489.68,358.65) ;
\draw [shift={(488.41,360.2)}, rotate = 309.32] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Cube [id:dp41311458155167946] 
\draw   (466.77,307.72) -- (484.72,289.77) -- (583.65,289.77) -- (583.65,315.75) -- (565.7,333.7) -- (466.77,333.7) -- cycle ; \draw   (583.65,289.77) -- (565.7,307.72) -- (466.77,307.72) ; \draw   (565.7,307.72) -- (565.7,333.7) ;
%Shape: Axis 2D [id:dp09007049367762732] 
\draw  (518.71,484.14) -- (591.93,484.14)(526.04,414.91) -- (526.04,491.84) (584.93,479.14) -- (591.93,484.14) -- (584.93,489.14) (521.04,421.91) -- (526.04,414.91) -- (531.04,421.91)  ;
%Straight Lines [id:da7551423149111343] 
\draw    (530.76,478.33) -- (485.01,531.69) ;
\draw [shift={(483.71,533.21)}, rotate = 310.61] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Axis 2D [id:dp7930036978994484] 
\draw  (93.76,489.64) -- (92.74,419.72)(17.43,483.55) -- (102.12,482.55) (87.84,426.78) -- (92.74,419.72) -- (97.84,426.66) (24.5,488.47) -- (17.43,483.55) -- (24.36,478.47)  ;
%Straight Lines [id:da0514151325879022] 
\draw    (86.57,489.27) -- (142.57,432.74) ;
\draw [shift={(143.97,431.32)}, rotate = 134.73] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Cube [id:dp36832123870677336] 
\draw   (465.07,497.31) -- (512.09,450.29) -- (583.46,450.29) -- (583.46,473.72) -- (536.45,520.73) -- (465.07,520.73) -- cycle ; \draw   (583.46,450.29) -- (536.45,497.31) -- (465.07,497.31) ; \draw   (536.45,497.31) -- (536.45,520.73) ;
%Shape: Cube [id:dp9643780074556838] 
\draw   (34.81,455.43) -- (45.24,445) -- (151.5,445) -- (151.5,494.4) -- (141.07,504.83) -- (34.81,504.83) -- cycle ; \draw   (151.5,445) -- (141.07,455.43) -- (34.81,455.43) ; \draw   (141.07,455.43) -- (141.07,504.83) ;
%Shape: Cube [id:dp238953851849667] 
\draw   (61.16,613.41) -- (73.49,601.08) -- (136.45,601.08) -- (136.45,689.61) -- (124.12,701.94) -- (61.16,701.94) -- cycle ; \draw   (136.45,601.08) -- (124.12,613.41) -- (61.16,613.41) ; \draw   (124.12,613.41) -- (124.12,701.94) ;
%Shape: Axis 2D [id:dp7592681759502293] 
\draw  (520.6,633.44) -- (583.46,633.44)(526.88,704.68) -- (526.88,625.52) (576.46,638.44) -- (583.46,633.44) -- (576.46,628.44) (521.88,697.68) -- (526.88,704.68) -- (531.88,697.68)  ;
%Straight Lines [id:da36047739383645205] 
\draw    (532.64,627.06) -- (472.79,695.82) ;
\draw [shift={(471.47,697.33)}, rotate = 311.04] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Cube [id:dp22943768586952062] 
\draw   (489.35,596.31) -- (501.68,583.98) -- (564.64,583.98) -- (564.64,672.52) -- (552.31,684.85) -- (489.35,684.85) -- cycle ; \draw   (564.64,583.98) -- (552.31,596.31) -- (489.35,596.31) ; \draw   (552.31,596.31) -- (552.31,684.85) ;

% Text Node
\draw (133.46,136.2) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (78.87,54.99) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (37.47,186.63) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (150.78,82.09) node [anchor=north west][inner sep=0.75pt]  [xslant=0.01] [align=left] {The initial orientation of our book. The large flat \\side denotes the x-axis, small top denotes y, \\and long flat spine denotes z. At each rotation,\\notice how the axis corresponding to the number\\in the sequence remains pointing in the same\\direction.};
% Text Node
\draw (571.06,136.2) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (516.48,54.99) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (475.07,186.63) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (26.59,21.33) node [anchor=north west][inner sep=0.75pt]   [align=left] {3-2-1 sequence};
% Text Node
\draw (173.59,274.9) node [anchor=north west][inner sep=0.75pt]   [align=left] {The first rotation of the book. As the \\first rotation of each sequence is the \\same, this orientation is identical for \\both orders.};
% Text Node
\draw (79.82,231.93) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (3.59,308.86) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (37.47,361.86) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (150.4,570.42) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (91.11,556.75) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (158.87,641.37) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (518.36,230.22) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (434.6,304.59) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (476.01,358.44) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (183.32,437.99) node [anchor=north west][inner sep=0.75pt]   [align=left] {The second rotation of the book. At\\this point, differences appear in the\\orientation of each book depending\\on what sequence it follows.};
% Text Node
\draw (519.3,393.49) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (471.31,532.81) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (597.41,473.83) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (148.51,414.85) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (4.53,472.13) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (87.34,400.32) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (176.44,545.1) node [anchor=north west][inner sep=0.75pt]   [align=left] {The third and final rotation. If the axis \\weren't present in this image, your first\\thought might be that the orientations\\are identical; however, that isn't the case\\and you can see the axis. This shows\\that while every rotation sequece can\\end in a similar orientation, it takes \\different angles of rotation to achieve an\\identical ending orientation. This will have\\an impact on the derivation of our rotation\\matrix. };
% Text Node
\draw (456.25,689.24) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (522.13,707.19) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (588.94,622.57) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (473,20) node [anchor=north west][inner sep=0.75pt]   [align=left] {3-1-3 sequence};


\end{tikzpicture}

    \caption{Visualization of 3-Dimensional Rotation Sequences}
    \label{fig:3DParallelVisualization}
\end{figure}

Reinforcing the idea that different rotations are needed to achieve identical ending orientations for different rotation sequences, say you change the final 3-1-3 rotation to be -90 degrees. That ending orientation would now be perfectly identical to the 3-2-1 sequence! So despite what sequence you use, every possible ending orientation has the ability to be described by every rotation sequence, albeit with different individual angles of rotation. Now that we’ve seen the differences between the rotation sequences in the physical world, let’s try to describe them in the realm of mathematics. We will be following the 3-2-1 rotation sequence shown on the left of the image above. Like how we were able to visualize them above, we’re going to break each rotation down into smaller sets. In total we will go from the initial frame ($\hat{x}$,$\hat{y}$,$\hat{z}$), to the first intermediate frame (denoted by prime: $x'$), to the second intermediate frame (denoted by double prime: $x''$), to our final body frame ($\hat{X}$,$\hat{Y}$,$\hat{Z}$).
$$(\hat{x},\hat{y},\hat{z})\rightarrow(\hat{x}',\hat{y}',\hat{z}')\rightarrow(\hat{x}'',\hat{y}'',\hat{z}'')\rightarrow(\hat{X},\hat{Y},\hat{Z})$$

Having broken the big picture down into smaller, simpler ones, we can see that this daunting manipulation of the vehicle’s orientation in 3-dimensional space is merely a set of three simple 2-dimensional rotations in a set sequence (a fact heavily implied by the spatial manipulation of the textbook earlier!). The gls{Euler angles} correspond to a 2-dimensional rotation about a paired axis. Our angle $\psi$ pairs with the z-axis and typically corresponds to the yaw of an aircraft, $\theta$ pairs with the y-axis and the pitch, while $\phi$ pairs with the x-axis and the roll. Images \ref{fig:BodyFrameTypical} and \ref{fig:BodyFrameRocket} reflect this, visualizing the standard and specific conventions for such a notation.

Utilizing this information and recalling our rotation matrix from 2-dimensional space \eqref{eq:2DMatrix} we can expand to 3-dimensional space. Our angle $\psi$, with it’s connection to the z-axis needs that axis to remain “stationary”. Therefore, the third component of the vector we are rotating about will always be multiplied by 1. Before throwing this in a matrix, let’s double check the rotation matrix for a vector also applies for the rotation of a frame.

Visualizing the rotation of the prime frame with respect to the initial frame by an angle $\psi$ about the z-axis, we get:

\begin{figure}[H]
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Axis 2D [id:dp8814120358250415] 
\draw  (294.8,194.88) -- (467,194.88)(312.02,48) -- (312.02,211.2) (460,189.88) -- (467,194.88) -- (460,199.88) (307.02,55) -- (312.02,48) -- (317.02,55)  ;
%Shape: Axis 2D [id:dp1264953723655049] 
\draw  (297.24,203.72) -- (445.04,115.36)(236.66,68.81) -- (320.39,208.89) (436.47,114.66) -- (445.04,115.36) -- (441.6,123.24) (235.96,77.38) -- (236.66,68.81) -- (244.54,72.25)  ;
%Curve Lines [id:da4379409407097825] 
\draw    (391.8,194.2) .. controls (389.87,170.07) and (387.01,171.09) .. (376.03,159.51) ;
\draw [shift={(374.8,158.2)}, rotate = 47.29] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da47080870387004614] 
\draw    (311.8,126.2) .. controls (291.74,122.38) and (289.02,131.33) .. (282.72,142.59) ;
\draw [shift={(281.8,144.2)}, rotate = 300.26] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da40076953586454556] 
\draw    (309.8,220.8) .. controls (350.39,210.9) and (319.43,157.88) .. (282.91,192.72) ;
\draw [shift={(281.8,193.8)}, rotate = 315] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (470,182.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (307,24.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (449,96.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{x'}$};
% Text Node
\draw (225,42.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{y'}$};
% Text Node
\draw (281,104.4) node [anchor=north west][inner sep=0.75pt]    {$\psi $};
% Text Node
\draw (395,162.4) node [anchor=north west][inner sep=0.75pt]    {$\psi $};
% Text Node
\draw (254,191.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} ,\widehat{z'}$};

\end{tikzpicture}
   
    \caption{First Frame Rotation in 3-2-1 Sequence}
    \label{fig:3DZRotation}
\end{figure}

Computing the trigonometry to translate from the initial to prime frame, we get the following set of equations:
$$\hat{x}'=cos(\psi)\hat{x}+sin(\psi)\hat{y}$$
$$\hat{y}'=-sin(\psi)\hat{x}+cos(\psi)\hat{y}$$
$$\hat{z}'=\hat{z}$$
Concatenating these into a single matrix, we get the following rotation matrix about the z-axis in 3-dimensional space for a 3-2-1 rotation:
\begin{equation}\label{eq:3DZMatrix}
R(\psi)=\begin{bmatrix}
    cos(\psi)&sin(\psi)&0\\-sin(\psi)&cos(\psi)&0\\0&0&1
\end{bmatrix}
\end{equation}
We can see this matrix is in fact different from our 2-dimensional rotation matrix \eqref{eq:2DMatrix}! The reason for this stems from the fact that while in 2-dimensions, we were rotating a vector, we are now rotating an entire frame at once in 3-dimensions. This difference has a subtle impact on the trigonometry of the problem, leading to the negative sine term switching across the diagonal. Performing the same process for our y-axis ($\theta$) we get the image and equations shown below:

\begin{figure}[H]
    
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Axis 2D [id:dp10624606154766014] 
\draw  (289.8,225.88) -- (462,225.88)(307.02,79) -- (307.02,242.2) (455,220.88) -- (462,225.88) -- (455,230.88) (302.02,86) -- (307.02,79) -- (312.02,86)  ;
%Shape: Axis 2D [id:dp07151631286404303] 
\draw  (292.24,234.72) -- (440.04,146.36)(231.66,99.81) -- (315.39,239.89) (431.47,145.66) -- (440.04,146.36) -- (436.6,154.24) (230.96,108.38) -- (231.66,99.81) -- (239.54,103.25)  ;
%Curve Lines [id:da006532196783956223] 
\draw    (386.8,225.2) .. controls (384.87,201.07) and (382.01,202.09) .. (371.03,190.51) ;
\draw [shift={(369.8,189.2)}, rotate = 47.29] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da19094795610816706] 
\draw    (306.8,157.2) .. controls (286.74,153.38) and (284.02,162.33) .. (277.72,173.59) ;
\draw [shift={(276.8,175.2)}, rotate = 300.26] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da8842649250634054] 
\draw    (304.8,251.8) .. controls (345.39,241.9) and (314.43,188.88) .. (277.91,223.72) ;
\draw [shift={(276.8,224.8)}, rotate = 315] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (465,213.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{z'}$};
% Text Node
\draw (302,55.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{x'}$};
% Text Node
\draw (444,127.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{z''}$};
% Text Node
\draw (220,73.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{x''}$};
% Text Node
\draw (276,135.4) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
% Text Node
\draw (390,193.4) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
% Text Node
\draw (242,230.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{y'} ,\widehat{y''}$};


\end{tikzpicture}

    \caption{Second Frame Rotation in 3-2-1 Sequence}
    \label{fig:3DYRotation}

\end{figure}
$$\hat{x}''=cos(\theta)\hat{x}'-sin(\theta)\hat{z}'$$
$$\hat{y}''=\hat{y}'$$
$$\hat{z}''=sin(\theta)\hat{x}'+cos(\theta)\hat{z}'$$
And finally the matrix:
$$R(\theta)=\begin{bmatrix}
    cos(\theta)&0&-sin(\theta)\\0&1&0\\sin(\theta)&0&cos(\theta)
\end{bmatrix}$$
Finally for our x-axis ($\phi$), we get the image and equation below:

\begin{figure}[H]
    \centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Axis 2D [id:dp37741929808299357] 
\draw  (265.8,214.88) -- (438,214.88)(283.02,68) -- (283.02,231.2) (431,209.88) -- (438,214.88) -- (431,219.88) (278.02,75) -- (283.02,68) -- (288.02,75)  ;
%Shape: Axis 2D [id:dp4057280236537508] 
\draw  (268.24,223.72) -- (416.04,135.36)(207.66,88.81) -- (291.39,228.89) (407.47,134.66) -- (416.04,135.36) -- (412.6,143.24) (206.96,97.38) -- (207.66,88.81) -- (215.54,92.25)  ;
%Curve Lines [id:da7885616787760448] 
\draw    (362.8,214.2) .. controls (360.87,190.07) and (358.01,191.09) .. (347.03,179.51) ;
\draw [shift={(345.8,178.2)}, rotate = 47.29] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da4316718282657035] 
\draw    (282.8,146.2) .. controls (262.74,142.38) and (260.02,151.33) .. (253.72,162.59) ;
\draw [shift={(252.8,164.2)}, rotate = 300.26] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da8810661168844911] 
\draw    (280.8,240.8) .. controls (321.39,230.9) and (290.43,177.88) .. (253.91,212.72) ;
\draw [shift={(252.8,213.8)}, rotate = 315] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (441,202.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{y''}$};
% Text Node
\draw (278,44.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{z''}$};
% Text Node
\draw (420,116.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{Y}$};
% Text Node
\draw (196,62.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{Z}$};
% Text Node
\draw (252,124.4) node [anchor=north west][inner sep=0.75pt]    {$\phi $};
% Text Node
\draw (366,182.4) node [anchor=north west][inner sep=0.75pt]    {$\phi $};
% Text Node
\draw (218,219.4) node [anchor=north west][inner sep=0.75pt]    {$\widehat{x''} ,\hat{X}$};


\end{tikzpicture}
    \caption{Final Frame Rotation in 3-2-1 Sequence}
    \label{fig:3DXRotation}
\end{figure}
$$\hat{X}=\hat{x}''$$
$$\hat{Y}=cos(\phi)\hat{y}''+sin(\phi)\hat{z}''$$
$$\hat{Z}=-sin(\phi)\hat{y}''+cos(\phi)\hat{z}''$$
And finally our last matrix:
$$R(\phi)=\begin{bmatrix}
    1&0&0\\0&cos(\phi)&sin(\phi)\\0&-sin(\phi)&cos(\phi)
\end{bmatrix}$$
Note it is VERY important to derive the individual rotation matrices with simple trigonometry for each axis if you choose a different rotation sequence, as the terms of each element in the matrix elements may change depending on what you do!

\subsection{The Direction Cosine Matrix}\label{sec:TheDCM}
Having matrices for each individual rotation is a great start; however, we want to get to the form:
\begin{equation}\label{eq:EulerRotation}
\vec{R}=A_{3,2,1}\vec{r}
\end{equation}
The 3x3 matrix $A_{3,2,1}$ is the \textit{Direction Cosine Matrix} or \textit{DCM}. This is the final, 3-dimensional rotation matrix you multiply with your inertial vector to express any vector in your body frame. Intuitively, we can presume the DCM will be some matrix multiplication of the three individual rotations. But in what order do we multiply our individual axis rotation matrices together? Remember, order matters in matrix multiplication as it is NOT commutative. So, determining the proper order is essential to the accuracy of the equation.

To work through this, we’re going to fall back on the tried-and-true method of visualization. Looking back at the image of our book, we’re going to replace the book with only the axis. The following set of images moves through these rotations; however, on a 2-dimensional piece of paper it’s a bit difficult to depict a 3-dimensional rotation.

\begin{figure}[H]
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,723); %set diagram left start at 0, and has height of 723

%Shape: Axis 2D [id:dp169089929067181] 
\draw  (113.61,91.42) -- (207.61,91.42)(123.01,21.27) -- (123.01,99.22) (200.61,86.42) -- (207.61,91.42) -- (200.61,96.42) (118.01,28.27) -- (123.01,21.27) -- (128.01,28.27)  ;
%Straight Lines [id:da807678379259174] 
\draw    (130.34,86.28) -- (75.52,128.71) ;
\draw [shift={(73.94,129.93)}, rotate = 322.26] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Axis 2D [id:dp7622456541943443] 
\draw  (117.37,252) -- (211.37,252)(126.77,181.85) -- (126.77,259.8) (204.37,247) -- (211.37,252) -- (204.37,257) (121.77,188.85) -- (126.77,181.85) -- (131.77,188.85)  ;
%Straight Lines [id:da7627359224242283] 
\draw    (134.1,246.86) -- (79.28,289.28) ;
\draw [shift={(77.7,290.51)}, rotate = 322.26] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da9944755330031119] 
\draw    (126.77,252) -- (208.24,252.15) ;
\draw [shift={(210.24,252.16)}, rotate = 180.11] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8159551049186013] 
\draw    (133.35,259.8) -- (82.71,196.81) ;
\draw [shift={(81.46,195.25)}, rotate = 51.2] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da2841054255340081] 
\draw    (129.4,245.14) -- (97.35,312.71) ;
\draw [shift={(96.5,314.52)}, rotate = 295.37] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da4204693895037821] 
\draw    (124.89,211.47) .. controls (113.99,207.17) and (109.2,209.77) .. (103.11,219.4) ;
\draw [shift={(102.14,220.98)}, rotate = 301.09] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da10253203244713682] 
\draw    (97.44,275.54) .. controls (94.72,285.32) and (94.62,289.29) .. (109.82,284.65) ;
\draw [shift={(111.54,284.12)}, rotate = 162.13] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8112981285659084] 
\draw    (350.5,252) -- (431.98,252.15) ;
\draw [shift={(433.98,252.16)}, rotate = 180.11] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da22117378034771829] 
\draw    (363.66,258.24) -- (313.02,195.25) ;
\draw [shift={(311.77,193.69)}, rotate = 51.2] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da6076277803798291] 
\draw    (360.65,245.92) -- (328.61,313.49) ;
\draw [shift={(327.75,315.3)}, rotate = 295.37] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da22428135782433367] 
\draw    (126.77,433.63) -- (208.24,433.78) ;
\draw [shift={(210.24,433.78)}, rotate = 180.11] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da6183300172376611] 
\draw    (139.93,439.86) -- (89.29,376.88) ;
\draw [shift={(88.04,375.32)}, rotate = 51.2] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da7023296453623051] 
\draw    (136.92,427.54) -- (104.87,495.11) ;
\draw [shift={(104.02,496.92)}, rotate = 295.37] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8491036796335945] 
\draw    (144.63,438.15) -- (62.6,401.24) ;
\draw [shift={(60.77,400.42)}, rotate = 24.22] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da9327416644156861] 
\draw    (124.89,439.71) -- (191.6,400.65) ;
\draw [shift={(193.32,399.64)}, rotate = 149.65] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da18651531365927365] 
\draw    (176.59,434.25) .. controls (195.07,419.96) and (184.33,415.69) .. (173.57,412.63) ;
\draw [shift={(171.7,412.11)}, rotate = 15.45] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da031042459135772082] 
\draw    (108.91,399.95) .. controls (95.47,402.59) and (93.84,403.44) .. (91.35,412.59) ;
\draw [shift={(90.86,414.45)}, rotate = 284.49] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8477850498962038] 
\draw    (368.17,430.66) -- (336.13,498.23) ;
\draw [shift={(335.27,500.04)}, rotate = 295.37] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8683274216475789] 
\draw    (373.06,438.93) -- (291.03,402.02) ;
\draw [shift={(289.21,401.2)}, rotate = 24.22] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da6438781119062607] 
\draw    (358.96,440.48) -- (425.67,401.43) ;
\draw [shift={(427.4,400.42)}, rotate = 149.65] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da784757290818016] 
\draw    (129.4,602.93) -- (97.35,670.5) ;
\draw [shift={(96.5,672.31)}, rotate = 295.37] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da5207150108611938] 
\draw    (134.29,611.2) -- (52.26,574.29) ;
\draw [shift={(50.43,573.47)}, rotate = 24.22] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da3827560154389007] 
\draw    (120.19,612.76) -- (186.9,573.7) ;
\draw [shift={(188.62,572.69)}, rotate = 149.65] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da7174569054516935] 
\draw    (120.19,617.59) -- (168.58,556.48) ;
\draw [shift={(169.82,554.92)}, rotate = 128.38] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da9275189259533729] 
\draw    (124.7,602.15) -- (137.31,670.03) ;
\draw [shift={(137.67,672)}, rotate = 259.48] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da9856031421968732] 
\draw    (355.2,611.98) -- (273.17,575.07) ;
\draw [shift={(271.35,574.25)}, rotate = 24.22] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da7331613532371395] 
\draw    (348.43,602.93) -- (361.04,670.81) ;
\draw [shift={(361.41,672.78)}, rotate = 259.48] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8402538325418802] 
\draw    (342.98,618.37) -- (391.37,557.26) ;
\draw [shift={(392.62,555.7)}, rotate = 128.38] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da10285996627493943] 
\draw    (161.55,587.97) .. controls (166.54,578.41) and (161.45,578.9) .. (154.79,577.26) ;
\draw [shift={(152.9,576.74)}, rotate = 17.27] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da7838509707746697] 
\draw    (108.91,645.65) .. controls (116.93,652.15) and (113.63,656.02) .. (132.3,648.42) ;
\draw [shift={(134.1,647.68)}, rotate = 157.48] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (117.95,0.97) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (58.72,123.36) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (211.95,80.48) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (280.54,41.24) node [anchor=north west][inner sep=0.75pt]   [align=left] {Our original inertial frame\\of the vehicle.};
% Text Node
\draw (121.71,161.55) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (62.48,283.93) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (215.2,241.06) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} ,\hat{z} '$};
% Text Node
\draw (101.94,192.17) node [anchor=north west][inner sep=0.75pt]    {$\psi $};
% Text Node
\draw (88.77,284.16) node [anchor=north west][inner sep=0.75pt]    {$\psi $};
% Text Node
\draw (71.79,177.14) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} '$};
% Text Node
\draw (87.77,314.34) node [anchor=north west][inner sep=0.75pt]    {$\hat{y} '$};
% Text Node
\draw (298.35,174.8) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} '$};
% Text Node
\draw (314.33,313.56) node [anchor=north west][inner sep=0.75pt]    {$\hat{y} '$};
% Text Node
\draw (437.51,241.06) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} '$};
% Text Node
\draw (465.2,206.54) node [anchor=north west][inner sep=0.75pt]   [align=left] {Our first rotation\\about the z/z' axis \\by an angle of \\ \ \ \ degrees.};
% Text Node
\draw (469.5,261.55) node [anchor=north west][inner sep=0.75pt]    {$\psi $};
% Text Node
\draw (74.61,356.43) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} '$};
% Text Node
\draw (82.32,496.74) node [anchor=north west][inner sep=0.75pt]    {$\hat{y} ',\hat{y} ''$};
% Text Node
\draw (213.77,422.69) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} '$};
% Text Node
\draw (38.74,390.57) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} ''$};
% Text Node
\draw (195.76,384.33) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} ''$};
% Text Node
\draw (82.22,388.45) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
% Text Node
\draw (188.45,410.28) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
% Text Node
\draw (427.96,385.89) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} ''$};
% Text Node
\draw (273.76,385.89) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} ''$};
% Text Node
\draw (322.64,499.86) node [anchor=north west][inner sep=0.75pt]    {$\hat{y} ''$};
% Text Node
\draw (473.71,403.58) node [anchor=north west][inner sep=0.75pt]   [align=left] {Our next rotation\\about the y'/y'' axis by \\an angle of \ \ \ \ degrees.};
% Text Node
\draw (552.26,440.68) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
% Text Node
\draw (189.18,558.16) node [anchor=north west][inner sep=0.75pt]    {$\hat{z} ''$};
% Text Node
\draw (28.77,551.49) node [anchor=north west][inner sep=0.75pt]    {$\hat{x} '',\hat{X}$};
% Text Node
\draw (83.86,672.13) node [anchor=north west][inner sep=0.75pt]    {$\hat{y} ''$};
% Text Node
\draw (132.96,671.69) node [anchor=north west][inner sep=0.75pt]    {$\hat{Y}$};
% Text Node
\draw (167.74,532.16) node [anchor=north west][inner sep=0.75pt]    {$\hat{Z}$};
% Text Node
\draw (389.59,532.16) node [anchor=north west][inner sep=0.75pt]    {$\hat{Z}$};
% Text Node
\draw (356.69,672.47) node [anchor=north west][inner sep=0.75pt]    {$\hat{Y}$};
% Text Node
\draw (255.14,557.88) node [anchor=north west][inner sep=0.75pt]    {$\hat{X}$};
% Text Node
\draw (163.98,564) node [anchor=north west][inner sep=0.75pt]    {$\phi $};
% Text Node
\draw (112.28,655.2) node [anchor=north west][inner sep=0.75pt]    {$\phi $};
% Text Node
\draw (437.5,565.09) node [anchor=north west][inner sep=0.75pt]   [align=left] {The final rotation\\about the x''/X axis\\by an angle of \ \ \ \ degrees};
% Text Node
\draw (536.24,601.41) node [anchor=north west][inner sep=0.75pt]    {$\phi $};


\end{tikzpicture}



    \caption{3-2-1 Rotation Order}
    \label{fig:RotationOrder}
\end{figure}

Moving in order of our rotations, from 3 to 2 to 1, one might assume this is the proper order of matrix multiplication as well. However, looking at this case, this would be applying the rotations in the opposite order to how we should. We want the first rotation to be adjacent to our inertial vector, then the second rotation, and finally the last all the way to the left. This will allow each rotation to only impact and compound on the rotations after it. This reasoning will be reinforced later in \ref{sec:DescribeEulerRates}
For now, we can expand our original equation to the following form: 
$$\vec{R}=A_1(\phi)A_2(\theta)A_3(\psi)$$
This gives us the following equation for computing our DCM:
$$A_{3,2,1}=A_1A_2A_3=\begin{bmatrix}
    1&0&0\\0&cos(\phi)&sin(\phi)\\0&-sin(\phi)&cos(\phi)
\end{bmatrix}
\begin{bmatrix}
    cos(\theta)&0&-sin(\theta)\\0&1&0\\sin(\theta)&0&cos(\theta)
\end{bmatrix}
\begin{bmatrix}
    cos(\psi)&sin(\psi)&0\\-sin(\psi)&cos(\psi)&0\\0&0&1
\end{bmatrix}$$
Computing the matrix multiplication\footnote{Due to the size of the DCM, we've introduced a shorthand to make the matrix more readable. Namely, cosine is denoted as c() and sine as s().}, we get:
$$A_{3,2,1}=\begin{bmatrix}
    c(\theta)c(\psi)&c(\theta)s(\psi)&-s(\theta)\\
    s(\phi)s(\theta)c(\psi)-c(\phi)s(\psi)&s(\phi)s(\theta)s(\psi)+c(\phi)c(\psi)&s(\phi)c(\theta)\\
    c(\phi)s(\theta)c(\psi)+s(\phi)s(\psi)&c(\phi)s(\theta)s(\psi)-s(\phi)c(\psi)&c(\phi)c(\theta)
\end{bmatrix}$$

This sizable matrix is the final form of our DCM for the 3-2-1 rotation sequence, which translates everything from the inertial frame into the body frame. Due to its nature as a rotation matrix, it is a square orthogonal matrix, and therefore the inverse is equal to the transpose. This makes converting in the opposite direction from body to inertial just as easy, as we rewrite equation \eqref{eq:EulerRotation} to get:
$$\vec{r}=A_{3,2,1}^T\vec{R}$$

A quick note on the limitations of the DCM expressed with \gls{Euler angles}: for any rotation order you choose, there will exist an angle such that you effectively ''loose'' a direction of rotation. Taking our $A_{3,2,1}$ matrix, for example, it is apparent there is a lack of robustness when it comes to the $\theta$ direction. Let's plug in arbitrary values for $\psi$ and $\phi$, and $\theta=\pi/2$. This results in the following:
$$A_{3,2,1}(\psi,[\theta=\frac{\pi}{2}],\phi)=\begin{bmatrix}
    0&0&-1\\s(\phi)c(\psi)-c(\phi)s(\psi)&s(\phi)s(\psi)+c(\phi)c(\psi)&0\\
    c(\phi)c(\psi)+s(\phi)s(\psi)&c(\phi)s(\psi)-s(\phi)c(\psi)&0
\end{bmatrix}$$

This can be further simplified using trig identities as follows:
$$A_{3,2,1}(\psi,[\theta=\frac{\pi}{2}],\phi)=\begin{bmatrix}
    0&0&-1\\sin(\phi-\psi)&cos(\phi-\psi)&0\\
    cos(\phi-\psi)&sin(\phi-\psi)&0
\end{bmatrix}$$
In the form above, it becomes apparent that only the sum $\phi-\psi$ becomes available with $\theta$ nowhere to be found.\footnote{Note that in this case, this is generally true for the set \{$\theta=k\pi+(\pi/2)$, $k\in\mathbb{Z}$\}. However, the sign of each element of the final matrix will potentially be different.} This lack of a $\theta$ is what induces the ''loss'' of a degree of freedom in the simulation, as you can no longer express that specific direction within your DCM. Obviously, the loss of a degree of freedom is catastrophic to a simulation model such as a 6\gls{dof}. Luckily, there is a tool available that lets us avoid such a catastrophe! This method is the use of \glspl{quaternion} and will be discussed later \ref{sec:quaternions}. While being a more robust solution, \glspl{quaternion} are based on significantly more advanced mathematics. But we’ll get there eventually, for now we’ll talk about the derivatives of \gls{Euler angles} and their uses.

\subsection{Describing Angular Velocity with Euler Angles and Rates}

\newglossaryentry{Euler rates}
{
    name=Euler rates,
    first={\textit{Euler rates}},
    description={A way to describe rotational rates with orientation for 3-dimensional rotations, they are denoted by the dot of the corresponding Euler angle: ($\dot{\psi},\dot{\theta},\dot{\phi}$)}
}

In most simple 2-dimensional cases, the derivative of an angle as a function of time is angular velocity. However, in 3-dimensional space, these two are NOT equivalent. This stems from the fact that our \gls{Euler angles} describe the orientation of our vehicle in space, while angular velocity does not necessarily describe the orientation. This describes the necessity for Euler angle rates, or simply \gls{Euler rates}, as they give a way to describe the speed of rotation and orientation at once. To start describing the correlation between angular velocity and \gls{Euler rates}, just like our work deriving the DCM, we’ll start with smaller pieces and build up to the big picture.

In the individual rotations depicted in figure \ref{fig:RotationOrder}, we can derive the following equations for the angular velocity in each given each case is that of a simplified 2-dimensional one:
$$\dot{\boldsymbol{\psi}}=\prescript{x}{}{}\omega^{x'}$$
$$\dot{\boldsymbol{\theta}}=\prescript{x'}{}{}\omega^{x''}$$
$$\dot{\boldsymbol{\phi}}=\prescript{x''}{}{}\omega^X$$
With the knowledge that adding angular velocities between connecting frames is possible, we can write:
\begin{equation}\label{eq:AngularVelocityWithEulerRate}
\prescript{e}{}{}\omega^b=\prescript{x}{}{}\omega^X=\dot{\boldsymbol{\psi}}+\dot{\boldsymbol{\theta}}+\dot{\boldsymbol{\phi}}
\end{equation}
Where $\prescript{e}{}{}\omega^b$ is simply read as the angular velocity of the body frame in the earth frame. We can further equate this using the basis vectors of the body frame like so:
\begin{equation}\label{eq:AngularVelocityComponents}
    \prescript{e}{}{}\omega^b=\omega_X\hat{b}_1+\omega_Y\hat{b}_2+\omega_Z\hat{b}_3
\end{equation}
Our goal is to solve the right hand side of \eqref{eq:AngularVelocityWithEulerRate} - and therefore \eqref{eq:AngularVelocityComponents} - to give us an expression for the angular velocity of our rocket in terms of \gls{Euler angles} and \gls{Euler rates}. Intuitively, this means we want to find a way to take our simple 2-dimensional \gls{Euler rates} and convert them into the body frame to be able to do so. Luckily, we've already completed such a process in section \ref{sec:TheDCM}. Similar to our DCM, we will take each of the 2-dimensional \gls{Euler rates} and us matrix multiplication with our individual axis rotations to achieve our goal. Starting with the first rotation in our chosen sequence - the $\psi$ angle - we must first express $\dot{\boldsymbol{\psi}}$ as a full vector of appropriate size for matrix multiplication. This is as follows:
$$\dot{\boldsymbol{\psi}}=\dot{\psi}\hat{z}=\dot{\psi}\hat{z}'=\begin{bmatrix}
    0\\0\\\dot{\psi}
\end{bmatrix}$$
Having expressed our rate as a vector, we can now move onto the matrix multiplication. Setting up the process, we get the following:
$$\dot{\boldsymbol{\psi}}=\begin{bmatrix}
    1&0&0\\0&c(\phi)&s(\phi)\\0&-s(\phi)&c(\phi)
\end{bmatrix}\begin{bmatrix}
    c(\theta)&0&-s(\theta)\\0&1&0\\s(\theta)&0&c(\theta)
\end{bmatrix}\begin{bmatrix}
    c(\psi)&s(\psi)&0\\-s(\psi)&c(\psi)&0\\0&0&1
\end{bmatrix}\begin{bmatrix}
    0\\0\\\dot{\psi}
\end{bmatrix}$$
Before working through the matrix multiplication, we can make a simplification to make our life easier. That being removing the rightmost matrix from the equation. The physical reasoning behind this comes from the fact that this matrix is the individual rotation matrix about the same axis our $\dot{\psi}$. As we know from the definition that this axis will remain unrotated, we can drop this term. This reinforces the idea that this multiplication order for the DCM is correct, as the angle of the pitch has no effect on its own rate, while the other rotations do. We then get:
$$\dot{\boldsymbol{\psi}}=\begin{bmatrix}
    1&0&0\\0&c(\phi)&s(\phi)\\0&-s(\phi)&c(\phi)
\end{bmatrix}\begin{bmatrix}
    c(\theta)&0&-s(\theta)\\0&1&0\\s(\theta)&0&c(\theta)
\end{bmatrix}\begin{bmatrix}
    0\\0\\\dot{\psi}
\end{bmatrix}$$
Which becomes:
\begin{equation}\label{eq:PsiAngularVelocity}
    \dot{\boldsymbol{\psi}}=\begin{bmatrix}
        -\dot{\psi}sin(\theta)\\\dot{\psi}sin(\phi)cos(\theta)\\\dot{\psi}cos(\phi)cos(\theta)
    \end{bmatrix}
\end{equation}
And this is the expression of our $\dot{\boldsymbol{\psi}}$ vector in the body frame! We can now repeat a similar process for the remaining \gls{Euler rates}, moving on to our $\dot{\boldsymbol{\theta}}$ rate. Starting with an expansion into a vector we get:
$$\dot{\boldsymbol{\theta}}=\dot{\psi}\hat{y}'=\dot{\psi}\hat{y}''=\begin{bmatrix}
    0\\\dot{\theta}\\0
\end{bmatrix}$$
We can now compute the matrix multiplication for this case:
$$\dot{\boldsymbol{\theta}}=\begin{bmatrix}
    1&0&0\\0&c(\phi)&s(\phi)\\0&-s(\phi)&c(\phi)
\end{bmatrix}\begin{bmatrix}
    c(\theta)&0&-s(\theta)\\0&1&0\\s(\theta)&0&c(\theta)
\end{bmatrix}\begin{bmatrix}
    0\\\dot{\theta}\\0
\end{bmatrix}$$
Simplifying as before this equation becomes:
$$\dot{\boldsymbol{\theta}}=\begin{bmatrix}
    1&0&0\\0&c(\phi)&s(\phi)\\0&-s(\phi)&c(\phi)
\end{bmatrix}\begin{bmatrix}
    0\\\dot{\theta}\\0
\end{bmatrix}$$
Which we can now solve to get:
\begin{equation}\label{eq:ThetaAngularVelocity}
    \dot{\boldsymbol{\theta}}=\begin{bmatrix}
        0\\\dot{\theta}cos(\phi)\\-\dot{\theta}sin(\phi)
    \end{bmatrix}
\end{equation}
Having successfully found our expression for $\dot{\boldsymbol{\theta}}$, we now only have $\dot{\boldsymbol{\phi}}$ left, and this is the easiest case! Expanding into a vector we get as follows:
$$\dot{\boldsymbol{\phi}}=\dot{\phi}\hat{x}''=\dot{\phi}\hat{X}=\begin{bmatrix}
    \dot{\phi}\\0\\0
\end{bmatrix}$$
Seeing as this is already expressed in the body frame, we don't have to do anything! We simply write our body frame expression to be:
\begin{equation}\label{eq:PhiAngularVelocity}
    \dot{\boldsymbol{\phi}}=\begin{bmatrix}
    \dot{\phi}\\0\\0
\end{bmatrix}
\end{equation}
We have completed the difficult task of expressing each of our \gls{Euler rates} in the body frame. Now, we must simply use \eqref{eq:AngularVelocityWithEulerRate} to connect our \gls{Euler rates} with our angular velocity. Doing so using the expressions \eqref{eq:PsiAngularVelocity}, \eqref{eq:ThetaAngularVelocity}, and \eqref{eq:PhiAngularVelocity}, we get the following equation:
$$\prescript{e}{}{}\omega^b=\prescript{x}{}{}\omega^X=\dot{\boldsymbol{\psi}}+\dot{\boldsymbol{\theta}}+\dot{\boldsymbol{\phi}}=\begin{bmatrix}
        -\dot{\psi}sin(\theta)\\\dot{\psi}sin(\phi)cos(\theta)\\\dot{\psi}cos(\phi)cos(\theta)
    \end{bmatrix}+\begin{bmatrix}
        0\\\dot{\theta}cos(\phi)\\-\dot{\theta}sin(\phi)
    \end{bmatrix}+\begin{bmatrix}
    \dot{\phi}\\0\\0
\end{bmatrix}$$
Actually solving the equation gets the following:
\begin{equation}\label{eq:AngularVelocityWithEulers}
    \prescript{e}{}{}\omega^b=\begin{bmatrix}
        -\dot{\psi}sin(\theta)+\dot{\phi}\\
        \dot{\psi}sin(\phi)cos(\theta)+\dot{\theta}cos(\phi)\\
        \dot{\psi}cos(\phi)cos(\theta)-\dot{\theta}sin(\phi)
    \end{bmatrix}
\end{equation}
And thus we have an expression connecting our angular velocity to our \gls{Euler rates} using the \gls{Euler angles}, just as we wanted.

\subsection{Describing Euler rates with Angular Velocities and Euler Angles}\label{sec:DescribeEulerRates}

Having just completed the derivation to describe the angular velocity of our vehicle with \gls{Euler rates} and Angles, a question naturally arises regarding the possibility of doing the inverse operation. Are we able to describe the \gls{Euler rates} in terms of the Angular Velocity and \gls{Euler angles}? Having a section dedicated to this topic, I'd say the answer seems obvious. 

In order to do so; however, we want to rewrite \eqref{eq:AngularVelocityWithEulers} in terms of each component as in \eqref{eq:AngularVelocityComponents}. Doing so is fairly simple, as each row corresponds to the component, and we derive the following:
\begin{equation}\label{eq:OmegaXComponent}
    \omega_X=-\dot{\psi}sin(\theta)+\dot{\phi}
\end{equation}
\begin{equation}\label{eq:OmegaYComponent}
    \omega_Y=\dot{\psi}sin(\phi)cos(\theta)+\dot{\theta}cos(\phi)
\end{equation}
\begin{equation}\label{eq:OmegaZComponent}
    \omega_Z=\dot{\psi}cos(\phi)cos(\theta)-\dot{\theta}sin(\phi)
\end{equation}
Having these three equations with three \gls{Euler rates} we want to solve for, a clever mix of elimination and substitution will allow us to derive what we want.

To start, we will solve for $\dot{\theta}$. Multiplying \eqref{eq:OmegaYComponent} by $cos(\phi)$ and \eqref{eq:OmegaZComponent} by $-sin(\phi)$, we get the following system:
$$\omega_Ycos(\phi)=\dot{\psi}sin(\phi)cos(\phi)cos(\theta)+\dot{\theta}cos^2(\phi)$$
$$-\omega_Zsin(\phi)=-\dot{\psi}sin(\phi)cos(\phi)cos(\theta)+\dot{\theta}sin^2(\phi)$$
Adding the two together, the first term on the right hand side drops, and the second simplifies to one, and we get:
\begin{equation}\label{eq:ThetaDot}
\dot{\theta}=\omega_Ycos(\phi)-\omega_Zsin(\phi)
\end{equation}
We can now move on to find $\dot{\psi}$. Multiplying \eqref{eq:OmegaYComponent} by $sin(\phi)$ and \eqref{eq:OmegaZComponent} by $cos(\phi)$, we get the following system:
$$\omega_Ysin(\phi)=\dot{\psi}sin^2(\phi)cos(\theta)+\dot{\theta}cos(\phi)sin(\phi)$$
$$\omega_Zcos(\phi)=\dot{\psi}cos^2(\phi)cos(\theta)-\dot{\theta}sin(\phi)cos(\phi)$$
Adding as before, this time the first right hand side term simplifies while the second term cancels, leaving:
$$\dot{\psi}cos(\theta)=\omega_Ysin(\phi)+\omega_Zcos(\phi)$$
\begin{equation}\label{eq:PsiDot}
    \dot{\psi}=\frac{1}{cos(\theta)}(\omega_Ysin(\phi)+\omega_Zcos(\phi)
\end{equation}
We now only have $\dot{\phi}$ remaining. Having just found an expression for $\dot{\psi}$, we can substitute into \eqref{eq:OmegaXComponent} to get the following:
$$\omega_X=-\frac{sin(\theta)}{cos(\theta)}(\omega_Ysin(\phi)+\omega_Zcos(\phi))+\dot{\phi}$$
$$\dot{\phi}=\omega_X+\frac{sin(\theta)}{cos(\theta)}(\omega_Ysin(\phi)+\omega_Zcos(\phi))$$
A final simplification gives:
\begin{equation}\label{eq:PhiDot}
    \dot{\phi}=\omega_X+tan(\theta)(\omega_Ysin(\phi)+\omega_Zcos(\phi))
\end{equation}
Having found an expression for the \gls{Euler rates} in terms of angular velocities and \gls{Euler angles} is wonderful; however, we can do even better. By now, it should be apparent that everything we do revolves around matrices. So, let's transform the individual expressions for \gls{Euler rates} into a case of matrix multiplication!
Starting with defining the form we want, we can write the system as:
$$\begin{bmatrix}
    \dot{\phi}\\\dot{\theta}\\\dot{\psi}
\end{bmatrix}=B\begin{bmatrix}
    \omega_X\\\omega_Y\\\omega_Z
\end{bmatrix}$$
All we need to do is write the appropriate coefficients of equations \eqref{eq:ThetaDot}, \eqref{eq:PsiDot}, and \eqref{eq:PhiDot} to the appropriate place in our $B$ matrix (a 3x3 matrix). Doing so we get the following $B$ matrix:
$$B=\begin{bmatrix}
    1&tan(\theta)sin(\phi)&tan(\theta)cos(\phi)\\
    0&cos(\phi)&-sin(\phi)\\
    0&\frac{sin(\phi)}{cos(\theta)}&\frac{cos(\phi)}{cos(\theta)}
\end{bmatrix}$$
This leads to the equation:
\begin{equation}\label{eq:EulerRatestoAngularVelocities}
    \begin{bmatrix}
    \dot{\phi}\\\dot{\theta}\\\dot{\psi}
\end{bmatrix}=\begin{bmatrix}
    1&tan(\theta)sin(\phi)&tan(\theta)cos(\phi)\\
    0&cos(\phi)&-sin(\phi)\\
    0&\frac{sin(\phi)}{cos(\theta)}&\frac{cos(\phi)}{cos(\theta)}
\end{bmatrix}\begin{bmatrix}
    \omega_X\\\omega_Y\\\omega_Z
\end{bmatrix}
\end{equation}
And there we have our final equation relating \gls{Euler rates} to Angular velocities using \gls{Euler angles}. A quick note on the B matrix: you are able to use it to relate Angular velocities to \gls{Euler rates}; however, you MUST use the inverse! The B matrix isn't an orthogonal matrix, so the transform isn't equivalent to the inverse in this case. Because of this, our altered form of \eqref{eq:EulerRatestoAngularVelocities} is as follows:
\begin{equation}\label{eq:AngularVelocitiestoEulerRates}
    \begin{bmatrix}
        \omega_X\\\omega_Y\\\omega_Z
    \end{bmatrix}=B^{-1}\begin{bmatrix}
        \dot{\phi}\\\dot{\theta}\\\dot{\psi}
    \end{bmatrix}
\end{equation}
The actual calculation of $B^{-1}$ will be left as an exercise to the reader; however, a reminder of the calculation of the inverse is included below:
$B^{-1}=\frac{adj(B)}{det(B)}$
where $adj(B)$ is the adjugate of $B$ and $det(B)$ is the determinant of $B$.

This concludes our initial discussion off \gls{Euler angles} and \gls{Euler rates}. While this is a great accomplishment, there still remains the unanswered problem of Gimbal locking the simulation for certain orientations of the body. This issue will motivate the study, derivation, and ultimate use of quaternions, which is a journey that we are now ready to embark on.

\section{Quaternions}\label{sec:quaternions}
\newglossaryentry{quaternion}
{
    name=quaternion,
    first = {\textit{quaternion}},
    description={An extension of the complex numbers with elements $j$ and $k$ added. The common form is expressed $q_1+q_2i+q_3j+q_4k$ (our notation) or $q_1i+q_2j+q_3k+q_4$. The algebra of quaternions is generally denoted $\mathbb{H}$}
}
It was a gorgeous October day in Dublin, and William Hamilton was on a stroll with his wife on his way to the Royal Irish Academy. Having worked on hyper-imaginary numbers for some time, answers had been slowly forming in his head. As he crossed a cobblestone bridge above the Royal Canal, the answer of a necessary, fourth dimension for calculating triples struck him like a freight train. He hastily carved the fundamental formula for quaternion multiplication, $i^2+j^2+k^2=ijk=-1$, into the stones he was walking on. And so, \glspl{quaternion} were born.

\subsection{Quaternion Notation}
\Glspl{quaternion}, in the simplest sense, are a set of hyper-imaginary numbers that obey the law Hamilton discovered above. They exist in a special 4-dimensional space ($\mathbb{H}$), called a hyper-sphere ($S^3$). Depicting a 3-dimensional rotation in 2-dimensional space was hard enough, but we’ll now one-up that effort by attempting to depict a 4-dimensional space on a 2-dimensional paper. This “visualization” is depicted below:


% INCLUDE VISUAL OF HYPERSPHERE HERE


The difficulty in picturing \glspl{quaternion} reflects the abstractness of the concept as a whole. This abstractness is what really makes \glspl{quaternion} so difficult to understand, and is why we will have to rely almost solely on mathematical expressions and relations for the remainder of this section.

One of the most important aspects of working with \glspl{quaternion} is understanding their notation. The basic structure of a \gls{quaternion} vector is as follows: 
$$\vec{q}=\begin{bmatrix}
    q_1\\q_2\\q_3\\q_4
\end{bmatrix}$$
This form above translates to the two most common possible ways of which term is declared to be the scalar quantity:
$$\vec{q}=q_1+q_2i+q_3j+q_4k$$
$$\vec{q}=q_1i+q_2j+q_3k+q_4$$
To reduce confusion, some notations may write the scalar quantity as simply k, with the numbered subscripts simply referring to the imaginary values. In addition, they may shorthand the imaginary components of the \gls{quaternion} in vector notation. An example of such is given corresponding to the first given form above:
$$\vec{q}=\begin{bmatrix}
    q_1\\\vec{q}_{2:4}
\end{bmatrix}$$
More notation forms are likely to exist (as there is no set standard) so ensure you first and foremost clarify what term is scalar, as identifying that term is crucial for the accuracy of your calculations. For our purposes, we will declare the first term to be our scalar, as not only is it more intuitive, but it also agrees with the MATLAB notation of a \gls{quaternion} vector. Therefore, our \gls{quaternion} vector appears as follows:
\begin{equation}\label{eq:QuatNotation}
    \vec{q}=q_1+q_2i+q_3j+q_4k
\end{equation}
The second most important aspect, albeit more niche to our own use, is the normalization of the \gls{quaternion} vector. As we want to utilize the \gls{quaternion} vector with rotations for defining orientation, it is critical and necessary to normalize them, as this is the only form with which we can encode rotations. We’ll get into why this is in the following sections, but for now, this normalized \gls{quaternion} is called a \gls{versor}. Make sure to not only confirm you know which value is scalar, but also to normalize your quats!

\newglossaryentry{versor}
{
    name=versor,
    first = {\textit{versor}},
    description={The normalization of a quaternion and the only way to encode rotations, it is equivalent to $\frac{\vec{q}}{||\vec{q}||}$. Fun note on the etymology of the word: it is derived from the Latin word ''versari'' which means ''to turn'' among other translations. With the suffix ''-or'', it becomes a noun, taking the meaning ''the turner''}
}

\subsection{Quaternion Mathematics}
In addition to understanding the notation of \glspl{quaternion}, it is also important to understand how basic mathematical operations work with respect to \glspl{quaternion}. Within this subsection, each individual subpart will discuss a separate mathematical operation, and will commonly refer to classic imaginary numbers as you are likely to have seen before.

\subsubsection{Addition}
The addition of two \glspl{quaternion} operates identically to the addition of two complex numbers. Every real part and every coefficient for each imaginary part is added together to create the summed \gls{quaternion}. A simple example of the sum of two \glspl{quaternion} $q+q'$ is shown below:
\begin{equation}\label{eq:QuatAddition}
    q+q'=(q_1+q_2i+q_3j+q_4k)+(q_1'+q_2'i+q_3'j+q_4'k)=(q_1+q_1')+(q_2+q_2')i+(q_3+q_3')j+(q_4+q_4')k
\end{equation}
Any \gls{quaternion} addition naturally returns the same result no matter which way you add them, they are commutative in addition ($q+q'=q'+q$). The reason for this should be fairly obvious.
\subsubsection{Scalar Multiplication}
The multiplication of a \gls{quaternion} by a scalar also operates identically to complex numbers. The scalar is distributed to and multiplied by every element of the \gls{quaternion}. Another simple example of scalar multiplication is shown below:
\begin{equation}
    sq=s(q_1+q_2i+q_3j+q_4k)=sq_1+sq_2i+sq_3j+sq_4k
\end{equation}
\subsubsection{Quaternion Multiplication}
The multiplication of a \gls{quaternion} by another \gls{quaternion} is similar to that of complex numbers. It is denoted by the operator $\otimes$. Before giving a general example of \gls{quaternion} multiplication, we must first remind ourselves of fundamental formula for \gls{quaternion} multiplication: $i^2=j^2=k^2=ijk=-1$. We also need to discuss the products of each term. To do this, we can create a scale for this for quick reference: 
$$\underset{\leftharpoondown}{\stackrel{\rightharpoonup}{ijkij}}$$
Reading this is fairly simple: if you move right, you end positive, and if you move left, you end negative (e.g. $i\cdot j=k$, $j\cdot i=-k$
With both of the above in mind, we can compute a general case of \gls{quaternion} multiplication $q\otimes q'$
\begin{equation}\label{eq:QuatMultiplication}
    q\otimes q'=(q_1+q_2i+q_3j+q_4k)\otimes(q_1'+q_2'i+q_3'j+q_4'k)
\end{equation}
$$=(q_1q_1'-q_2q_2'-q_3q_3'-q_4q_4')$$
$$+(q_1q_2'+q_2q_1'+q_3q_4'-q_4q_3')i$$
$$+(q_1q_3'-q_2q_4'+q_3q_1'+q_4q_2')j$$
$$+(q_1q_4'+q_2q_3'-q_3q_2'+q_4q_1')k$$
This lengthy solution can be condensed into a matrix that could be expanded to an identical solution for quaternion multiplication (See section \ref{sec:QuatMultiplyMatrix} in the appendix for the simple derivation):
\begin{equation}\label{eq:QuatMultiplyMatrix}
    \vec{q}\otimes\vec{q}'=\begin{bmatrix}
        q_1q_1'-(\vec{q}_{2:4}\cdot \vec{q}_{2:4}')\\
        q_1\vec{q}_{2:4}'+q_1'\vec{q}_{2:4}+(\vec{q}_{2:4}\times\vec{q}_{2:4}')
    \end{bmatrix}
\end{equation}
And so, we have a neat definition for quaternion multiplication.


\subsubsection{Hamiltonian Product}





\subsubsection{Conjugate of Quaternions}





\subsubsection{Inverse of Quaternions}





\subsection{Principal Axis Rotation Theorem}
\newglossaryentry{Euler axis}
{
    name=Euler axis,
    first = {\textit{Euler axis}},
    description={The axis about which a rotation of a body in space can be described by only a single rotation, denoted by $\vec{e}$}
}

One of the most important theorems in the derivation of \glspl{quaternion} is \textit{Euler’s Principal Rotation Theorem},
which dictates that any rotation of a rigid body in space can be described by a rotation of $\varphi$ about a single axis $\vec{n}$ called the \gls{Euler axis}. This \gls{Euler axis} is a unit vector with magnitude 1, which will be useful later. For now, an image of this is depicted below:
\begin{figure}[H]
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,479); %set diagram left start at 0, and has height of 479

%Shape: Axis 2D [id:dp2405194452321] 
\draw  (214,286.6) -- (469.8,286.6)(239.58,85) -- (239.58,309) (462.8,281.6) -- (469.8,286.6) -- (462.8,291.6) (234.58,92) -- (239.58,85) -- (244.58,92)  ;
%Straight Lines [id:da6294916293680479] 
\draw    (256.8,267) -- (154.33,381.51) ;
\draw [shift={(153,383)}, rotate = 311.82] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da24671838856505635] 
\draw    (239.58,286.6) -- (327.78,138.72) ;
\draw [shift={(328.8,137)}, rotate = 120.81] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da34048428895159] 
\draw    (295.8,160.2) .. controls (267.23,179.9) and (320.17,210.27) .. (329.41,175.82) ;
\draw [shift={(329.8,174.2)}, rotate = 102.2] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (233,58.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{e}_{1}$};
% Text Node
\draw (139,378.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{e}_{2}$};
% Text Node
\draw (478,274.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{e}_{3}$};
% Text Node
\draw (329,115.4) node [anchor=north west][inner sep=0.75pt]    {$\stackrel {\rightharpoonup}{n}$};
% Text Node
\draw (329,183.4) node [anchor=north west][inner sep=0.75pt]    {$\varphi $};

\end{tikzpicture}
    \caption{A Depiction of Euler's Principle Rotation Theorem}
    \label{fig:PrincipleAxisTheorem}
\end{figure}
Using this \gls{Euler axis} rotation description of a rotation, we can define the \gls{quaternion} simply with respect to this rotation using the methods described for 2-dimensional complex numbers in section \ref{sec:2DImaginary}: 
$$\vec{q}=e^{\frac{\varphi}{2}(n_1i+n_2j+n_3k)}$$
Expanding this, we can write this as a vector as follows:
$$\vec{q}=\vec{q}_{\vec{n}}(\varphi)=\begin{bmatrix}
    cos(\frac{\varphi}{2})\\\vec{n}sin(\frac{\varphi}{2})
\end{bmatrix}=\begin{bmatrix}
    cos(\frac{\varphi}{2})\\n_1sin(\frac{\varphi}{2})\\n_2sin(\frac{\varphi}{2})\\n_3sin(\frac{\varphi}{2})
\end{bmatrix}$$
This is great; however, it is useless if we can’t determine $\vec{n}$ itself. Before using \glspl{quaternion}, let’s solve this problem by generalizing it into a rotation with any vector $\vec{x}$. Recalling the DCM from the \gls{Euler angles} section, we can write a similar equation with a matrix $M$ and our principal axis $\vec{n}$:
$$\vec{n}=M\vec{n}$$
The reason for this being the definition of the \gls{Euler axis}, and the fact it always remains unaltered in this special case of rotations. We can write this as an eigenvalue problem for our vector $\vec{x}$, which actually becomes an eigenvector, with the characteristic polynomial of eigenvalues $\lambda$. This appears as follows:
$$\lambda\vec{x}=M\vec{x}$$
$$det(I_3\lambda-M)=0$$

By Euler’s rotation principle: there must exist an eigenvalue $\lambda=1$ (of multiplicity 1-3) to satisfy an axisymmetric rotation. In this instance, the \gls{Euler axis} $\hat{n}$ is an eigenvector of this linear system corresponding to the eigenvalue $\lambda=1$. 
With our 3x3 matrix, the characteristic polynomial  of our system above can be written as:
$$\lambda^3-tr(M)\lambda^2+tr(adj(M))\lambda-det(M)=0$$

As M is a rotation matrix - and therefore an orthogonal matrix - we know that the determinant of $M$ is 1 and the adjugate of $M$ is simply $M$. Using this, we can simplify the equation above like so:
$$\lambda^3-tr(M)\lambda^2+tr(M)\lambda-1=0$$
$$(\lambda-1)(\lambda^2+\lambda-tr(M)\lambda+1)=0$$
The root $(\lambda-1)=0$ in the equation above proves the existence of an eigenvalue $\lambda=1$ associated with the eigenvector $\hat{n}$.



\subsection{Compounding 2-Dimensional Rotations (Method I)}

\subsection{Relating Quaternions to Euler Angles (Method II)}

\subsection{Principle Axis Rotation Matrix (Method III)}\label{sec:PrincipleAxisRotationMatrix}

\newglossaryentry{skew-symmetric matrix}
{
    name=skew-symmetric matrix,
    first = {\textit{skew-symmetric matrix}},
    description={A matrix which obeys the property that every $a_{ij}=-a_{ji}$. This can be interpreted to mean every term across the diagonal is equal in magnitude, but opposite in sign. Sometimes called an anti-symmetric matrix or anti-metric matrix}
}

To make the solution to our characteristic polynomial useful, let’s translate it into a DCM for Euler axis rotations. Using our knowledge of rotations, we can say that the parallel component of a vector rotated about the principal axis will remain equivalent. This will be denoted by $\vec{x}_\parallel$. The only impacted components will be the perpendicular components denoted by $
\vec{x}_\perp$. This gives rise to the following:
\begin{equation}\label{eq:xDecomposed}
    \vec{x}=\vec{x}_\parallel+\vec{x}_\perp
\end{equation}

To make this format useable, we’re going to write each of these vector components in terms of the vector itself. While this sounds strange, we can use vector projections to achieve this.
Starting with the projection of $\vec{x}_\parallel$ onto $\vec{n}$, we get the equation:
$$\vec{x}_\parallel=\frac{\vec{x}\cdot\vec{n}}{||\vec{n}||^2}\vec{n}$$

With the knowledge that the norm of $\vec{n}$ is equal to 1, or $||\vec{n}||=1$, we can write the above equation as follows (see section \ref{sec:VecProjectSimplify} for explanation and proof):
$$\vec{x}_\parallel=(\vec{x}\cdot\vec{n})\vec{n}$$
\begin{equation}\label{eq:xParallel}
    \vec{x}_\parallel=(\vec{n}\vec{n}^T)\vec{x}
\end{equation}

Now that we have a relation between the original vector and the parallel component as a function of the principal axis, we can substitute \eqref{eq:xParallel} into the simple definition from equation \eqref{eq:xDecomposed} to express $\vec{x}_\perp$ in terms of $\vec{x}$ and $\vec{n}$. This equates to:
$$\vec{x}_\perp=\vec{x}-\vec{x}_\parallel$$
$$\vec{x}_\perp=\vec{x}-(\vec{n}\vec{n}^T)\vec{x}$$
\begin{equation}\label{eq:xPerpendicular}
    \vec{x}_\perp=(I_3-\vec{n}\vec{n}^T)\vec{x}
\end{equation}
Now we have equations for both components in terms of $\vec{x}$ and $\vec{n}$! We can translate this into a rotation matrix about our principal axis. Using our knowledge of general rotation matrices, we know a mix of sines and cosines will likely be paired with the perpendicular term, while the parallel term remains untouched. This translates to:
$$A_{\vec{n}}(\varphi)\vec{x}=\vec{x}_\parallel+\vec{x}_{\perp}cos(\varphi)-(\vec{n}\times\vec{x})sin(\varphi)$$
A quick note: the derivation of this expression will be proven in section \ref{sec:MathematicalProofRotations} which you can - and likely should - reference now for clarity. For now, we are going to plug in our previously found expressions for the parallel and perpendicular components of $\vec{x}$, equations \eqref{eq:xParallel} and \eqref{eq:xPerpendicular}, respectively to get:
$$A_{\vec{n}}(\varphi)\vec{x}=(\vec{n}\vec{n}^T)\vec{x}+(I_3-\vec{n}\vec{n}^T)\vec{x}cos(\varphi)-(\vec{n}\times\vec{x})sin(\varphi)$$
To actually derive the rotation matrix in terms of the \gls{Euler axis}, we divide both sides above by $\vec{x}$ to get our rotation matrix:
$$A_{\vec{n}}(\varphi)=(\vec{n}\vec{n}^T)+(I_3-\vec{n}\vec{n}^T)cos(\varphi)-\frac{\vec{n}\times\vec{x}}{\vec{x}}sin(\varphi)$$
While it is indeed nice to have an expression for our rotation matrix, the one we have now is a bit messy. Specifically, the coefficient to the sine term is messy. Ideally, we want to somehow recover the vector $\vec{x}$ from the numerator in order to simplify the fraction. Luckily, there is a mathematical operator available to us that we will be using to do just that. To derive this mysterious operator, let us first compute the cross product of two arbitrary vectors by hand:
$$\vec{x}\times\vec{y}=\begin{bmatrix}
    x_1\\x_2\\x_3
\end{bmatrix}\times\begin{bmatrix}
    y_1\\y_2\\y_3
\end{bmatrix}=\begin{bmatrix}
    x_2y_3-x_3y_2\\x_3y_1-x_1y_3\\x_1y_2-x_2y_1
\end{bmatrix}$$
The easiest way to simplify this is to turn it into a case of matrix multiplication. To obtain a $[3\times1]$ column vector from matrix multiplication, we know we need to do an operation with matrix sizes $[3\times{a}][a\times1]$ to return an answer of appropriate size. To determine $a$, we make the simplification that the second vector $[a\times1]$ could simply represent one of the two original vectors we had. This means $a$ takes on the value of 3, and the matrix $[a\times1]$ is the second vector $\vec{y}$. As for the first matrix, with a value of $a=3$ it becomes a square $[3\times3]$ matrix. We will denote this matrix as $[\vec{x}\times]$, turning the operation $[3\times{a}][a\times1]$ into $[\vec{x}\times]\vec{y}$.

The easiest way to determine the elements of $[\vec{x}\times]$ is by visual inspection, a thorough understanding of matrix multiplication, and a system of equations. Looking at the first row of our solution, we can observe it is a difference of products of terms from our two original vectors. We can also recall the first row and first column of our solution vector will depend on the first row of $[\vec{x}\times]$ and entirety of the column vector $\vec{y}$. Writing this in general terms:
$$x_2y_3-x_3y_2=[x\times]_{11}y_1+[x\times]_{12}y_2+[x\times]_{13}y_3$$
Solving for each $y$ term, we can find that the first row of $[\vec{x}\times]$ is as follows:
$$[\vec{x}\times]_{(1,:)}=\begin{bmatrix}
    0&-x_3&x_2
\end{bmatrix}$$
Doing the same for the second and third row of our solution will be left as an exercise to the reader; however, once completed we can concatenate them to form our completed $[\vec{x}\times]$ matrix:
\begin{equation}\label{eq:xCrossMatrix}
    [\vec{x}\times]=\begin{bmatrix}
        0&-x_3&x_2\\x_3&0&-x_1\\-x_2&x_1&0
    \end{bmatrix}
\end{equation}

Some quick observations about this matrix: it is made exclusively of terms of our first vector $\vec{x}$. In addition, it can be defined as a \gls{skew-symmetric matrix} with zeroes along the diagonal, and therefore a trace of zero\footnote{It is important to note that the fact $[\vec{x}\times]$ has zeroes on the diagonal and a trace of zero is merely coincidental, as the trace is computed as the sum of the diagonal elements}. 

Now that we've completed the derivation to the simplification of the cross product, we can apply this to our \gls{Euler axis} rotation matrix as intended. Writing $\vec{n}\times\vec{x}$ as $[\vec{n}\times]\vec{x}$, we can cancel the $\vec{x}$ that now appears in both the numerator and denominator to get the following:
$$A_{\vec{n}}(\varphi)=(\vec{n}\vec{n}^T)+(I_3-\vec{n}\vec{n}^T)cos(\varphi)-[\vec{n}\times]sin(\varphi)$$



\subsection{Quaternion Rotation Matrix}










\subsection{Quaternion Rates}\label{sec: quaternion rates}





\section{Individual and Comprehensive Mathematical Proofs using MATLAB}\label{sec:MathematicalProofRotations}

In this section, we will use MATLAB to confirm proper derivations and prove the equality of multiple cases from the entirety of the previous chapter. As a whole, the section will be separated into four parts: 2-dimensional rotations, Euler angles, quaternions, and a comprehensive comparison of Euler angles and quaternions. The purpose of this section is not only to verify the theoretical mathematics highlighted throughout the sections above, but also to give insight into the use of MATLAB's built-in functions relating to Attitude Dynamics.



\section{3D Rotation Example: Dzhanibekov effect}\label{sec:Dzhan}

\newglossaryentry{dzhan}
{
    name={Dzhanibekov Effect},
    first=\textit{Dzhanibekov Effect},
    description={A phenomenon in which rotation about an intermediate axis results in rotation about another axis. This phenomenon occurs with any body where the three PMOIs are not equal. It is easily seen with a tennis racket or a cell phone},
    see={pmoi}
}
To help digest the complex nature of attitude dynamics, a full example is especially useful. One of the consequences of Euler's Equations described %eqref equation above
above is that rotation about an intermediate axis is unstable. This effect is known as the Intermediate Axis Theorem or the \gls{dzhan}.

This is a good phenomenon to describe 3D rotations because it requires us to put together lots of knowledge throughout this section. Because our object rotates about all three axes, we must parametrize our rotation with \glspl{quaternion} to avoid possible singularities in the solution.

Before we can describe our system dynamics, we need to establish our coordinate system for this problem.

\begin{figure}[ht]
    \centering


\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300


%Shape: Circle [id:dp7493270463079389] 
\draw   (195,100) .. controls (195,86.19) and (206.19,75) .. (220,75) .. controls (233.81,75) and (245,86.19) .. (245,100) .. controls (245,113.81) and (233.81,125) .. (220,125) .. controls (206.19,125) and (195,113.81) .. (195,100) -- cycle ;
%Shape: Rectangle [id:dp8745965352536226] 
\draw   (135,70) -- (305,70) -- (305,130) -- (135,130) -- cycle ;
%Straight Lines [id:da5356768971699141] 
\draw [color={rgb, 255:red, 128; green, 128; blue, 128 }  ,draw opacity=1 ] [dash pattern={on 10.5pt off 1.5pt on 3pt off 1.5pt}]  (125,100) -- (315,100) ;
%Shape: Circle [id:dp11124327189723426] 
\draw   (365,100) .. controls (365,83.43) and (378.43,70) .. (395,70) .. controls (411.57,70) and (425,83.43) .. (425,100) .. controls (425,116.57) and (411.57,130) .. (395,130) .. controls (378.43,130) and (365,116.57) .. (365,100) -- cycle ;
%Straight Lines [id:da07234932776274916] 
\draw    (220,100) -- (220,62) ;
\draw [shift={(220,60)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da6659026149277345] 
\draw    (220,100) -- (254,100) ;
\draw [shift={(256,100)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da8158592711011072] 
\draw    (411,75) -- (505,75) ;
%Straight Lines [id:da1507348050424776] 
\draw    (411,125) -- (505,125) ;
%Straight Lines [id:da9455565481798273] 
\draw    (505,125) -- (505,75) ;
%Straight Lines [id:da5972499541109577] 
\draw [color={rgb, 255:red, 128; green, 128; blue, 128 }  ,draw opacity=1 ][fill={rgb, 255:red, 128; green, 128; blue, 128 }  ,fill opacity=1 ] [dash pattern={on 10.5pt off 1.5pt on 3pt off 1.5pt}]  (395,100) -- (520,100) ;
%Straight Lines [id:da4230804170313147] 
\draw    (395,100) -- (395,62) ;
\draw [shift={(395,60)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;
%Straight Lines [id:da58307827964758] 
\draw    (395,100) -- (429,100) ;
\draw [shift={(431,100)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (7.65,-2.3) .. controls (4.86,-0.97) and (2.31,-0.21) .. (0,0) .. controls (2.31,0.21) and (4.86,0.98) .. (7.65,2.3)   ;


% Text Node
\draw (322,88.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{x}$};
% Text Node
\draw (223,42.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (398,42.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{y}$};
% Text Node
\draw (526,87.4) node [anchor=north west][inner sep=0.75pt]    {$\hat{z}$};
% Text Node
\draw (247.5,167.4) node [anchor=north west][inner sep=0.75pt]    {$I_{x} =1.202\cdot 10^{5} \ g/mm^{2}$};
% Text Node
\draw (247.5,195.9) node [anchor=north west][inner sep=0.75pt]    {$I_{y} =4.615\cdot 10^{5} \ g/mm^{2}$};
% Text Node
\draw (247.5,224.4) node [anchor=north west][inner sep=0.75pt]    {$I_{z} =4.010\cdot 10^{5} \ g/mm^{2}$};


\end{tikzpicture}

    \caption{Non-Symmetric Body for Demonstrating Dzhanibekov Effect}
    \label{fig:Dzhan}
\end{figure}

\subsection{State Vector}
We'll start by describing our \gls{state vector} and initial conditions for this problem:

We define our original position is at the origin, giving us a position vector:
$$\vec{r}_0=\begin{bmatrix}
    0\\0\\0
\end{bmatrix}$$
We also define the initial velocity to be zero, giving a velocity vector:
$$\vec{v}_0=\begin{bmatrix}
    0\\0\\0
\end{bmatrix}$$
We also need an initial orientation. We can either directly initialize a \gls{quaternion} or write our initial orientation with \gls{Euler angles} and then convert to \glspl{quaternion}. Often, \gls{Euler angles} are more intuitive, so we will use these for our initialization. We can define an initial angle of all zeros, meaning that our body frame axes are initially coincident with the inertial frame. This gives \gls{Euler angles} of:
$$\begin{bmatrix}
    \phi\\\theta\\\psi
\end{bmatrix} =
\begin{bmatrix}
    0\\0\\0
\end{bmatrix}$$
Using the command "eul2quat" with a specification of "XYZ" for the frame, the initial \gls{quaternion} vector is given as:
$$\vec{q}_0=\begin{bmatrix}
    1\\0\\0\\0
\end{bmatrix}$$
Lastly, we need to describe the initial angular velocity. To properly demonstrate the effect, we need a small perturbation on our non-intermediate axes. We can write our omega vector as:
$$\vec{\omega}_0=\begin{bmatrix}
0.05\\0.05\\\pi
\end{bmatrix} rad/s$$

Putting all of the together, we arrive at our \gls{state vector}:
$$\vec{X}_0=\begin{bmatrix}
    \vec{r}_0\\\vec{v}_0\\\vec{\omega}_0\\\vec{q}_0
\end{bmatrix}$$
Which we can expand to the full form as a 13-element column vector:
$$\vec{X}_0=\begin{bmatrix}
    0\\0\\0\\0\\0\\0\\0.05\\0.05\\\pi\\1\\0\\0\\0
\end{bmatrix}$$
\subsection{Forces and Moments}
We can assume that we are operating in a 0-g environment (as this is where the effect is most prevalent) and that no body forces are acting on the object. We will also assume that air resistance in negligible and there are no losses. These assumptions mean that there are no forces that the acting on our body. Additionally, there are no moments on the body either. We have chosen this case for our example so that we can focus solely on the attitude dynamics.
\subsection{Attitude Dynamics}
Our attitude dynamics are fairly simple since there are no moments acting on the body. Our equations for the angular velocity rates in \eqref{eq: moment eq 2} reduce to:
\begin{gather}\label{eq: moment eq dzhan}
    \dot{\omega}_x=\frac{\left(I_y-I_z\right)\omega_y\omega_z}{I_x}\\
    \dot{\omega}_y=\frac{\left(I_z-I_x\right)\omega_z\omega_x}{I_y}\\
    \dot{\omega}_z=\frac{\left(I_x-I_y\right)\omega_y\omega_x}{I_z}
\end{gather}
To find our \gls{quaternion} rates, we simply use the same methods as in section \ref{sec: quaternion rates}. This gives us:
\begin{equation}
    \dot{\textbf{q}}=\frac{1}{2}\begin{bmatrix}
        0&-\omega_x&-\omega_y&-\omega_z\\
        \omega_x&0&\omega_z&-\omega_y\\
        \omega_y&-\omega_z&0&\omega_x\\
        \omega_z&\omega_y&-\omega_x&0
    \end{bmatrix}\vec{q}
\end{equation}
\subsection{Translating to Code}
With all of these defined, we can write the derivative of our \gls{state vector} as:
\begin{equation}
    \dot{\textbf{X}}=\begin{bmatrix}
        \vec{v}\\\vec{a}\\\vec{\alpha}\\\dot{\textbf{q}}
    \end{bmatrix}
\end{equation}
From here, we can implement this in "ode45". We show all of the code for this model in the appendix.

Our initialization of the \gls{state vector} and all of the basic setup in contained in the main file, shown in listing \ref{code:DzhanMain}. The code that gets the derivative of the \gls{state vector} is the function passed into ode45. This code is shown in listing \ref{code:DzhanInt}. There is additionally a file to display the rotation of the body in an animation, which is shown in listing \ref{code:DzhanRotVis}.

%% add listings.
\chapter{Aerodynamic Modeling}\label{sec: aerodynamics}
\begin{chapquote}{Werner Heisenberg}
''When I meet God, I am going to ask him two questions: Why relativity? And why turbulence? I really believe he will have an answer for the first.''
\end{chapquote}
In Section \ref{sec: 3DoF Case} we discussed the 4 fundamental forces on a vehicle and how we define their directions. In that section we did not define the magnitude of the aerodynamic forces, $F_L$ and $F_D$. The magnitude of these forces are quite difficult to calculate and require the most approximation to do correctly. The governing equation for calculating the magnitude of our aerodynamics is $\frac{1}{2}\rho_{\infty}V^2_{\infty}SC_X$, where $C_X$ is either $C_L$ or $C_D$.

% buckingham pi derivation of CD and CL - hugo

Despite the innocuous appearance of this equation, calculating the aerodynamics of our system is deceptively hard because the calculation of $C_X$ is very complicated. In fact, without real data, any calculation that we made of these values will just be an approximation.\footnote{Even with wind tunnel data, it is still likely that some approximations need to be made. Aerodynamics in general has no definite answers.} That being said, there are approaches we can take which will get us close enough to true values to prove useful.

\section{Aerodynamics Terminology}
Aerodynamics has a lot of terminology associated with it that is important to understand before we can approach modeling the aerodynamics of the system. We will mostly cover aerodynamics terminology for rockets, but the modeling done here should be transferable to aspects of aircraft systems as well.\footnote{The principles we describe are the same, but much of the modelling is simpler for rockets since they have axial symmetry in most cases. We will utilize these assumptions early on to simplify this section.}

While some of the theory here is not directly used in our 6-\gls{dof}, having an understanding of this will be greatly beneficial so we have chosen to include some background here. 
\subsection{Lift and Drag}\label{Lift and Drag}
We start this section by noting that lift and drag are just conventions that are commonly used to describe the aerodynamic force. It should be noted that both the lift and the drag arise from the same source - the air acting on the vehicle. It is simply convenient to define this resultant force with respect to the direction of the freestream velocity.

When modeling aerodynamic forces, we can imagine that two differential force elements act at each point along the body. At each point, there is a pressure which acts normal to the surface and a shear stress (you can think of it as a friction) that acts tangentially to the surface. These are shown in Figure \ref{fig:pressure and shear}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{Images/ShearStress.png}
    \caption{Pressure and Shear Stress on an Aerodynamic Surface}
    \label{fig:pressure and shear}
\end{figure}
Since a force is a pressure multiplied by an area, $F=pA$, we can integrate our pressure distribution over an area to understand the total forces that are acting on a geometry. Often, we see this expressed in the form of an integral over the length of the geometry. This length is denoted $c$, the chord length, in the example of the airfoil. These integrals are shown below:
\begin{gather}
    N'=\int_0^{c}{p_lu-p_u}{dx}+\int_0^{c}{\left[\tau_u\frac{dy_u}{dx} + \tau_l\frac{dy_l}{dx}\right]}{dx}\\\\
    A'=\int_0^{c}{\left[p_u\frac{dy_u}{dx} + p_l\frac{dy_l}{dx}\right]}{dx}+\int_0^c{(\tau_u+\tau_l)}{dx}
\end{gather}
Where the $N'$ and $A'$ are the normal and axial force on the aerodynamic surface. Here, the apostrophe (We would say 'N prime') refers to the fact that the force acts over a unit length in the $\hat{z}$ direction. We are assuming a unit length here since we are considering the 2-D case in this example. More generally, we would perform this calculation more generally in 3D, but that is beyond the scope of this example.

The normal force acts normal in the $\hat{y}$ direction and the axial force acts in the $\hat {x}$ direction as shown in Figure \ref{fig:pressure and shear}. Normal and axial forces are not commonly used in our modeling outside of these calculations. More often, we see the quantities lift and drag, which are defined with respect to the \gls{freestream} velocity. Using our knowledge from section \ref{sec:2D Rotations}, we can easily transform our normal and axial forces into a lift and drag using a rotation matrix with our \gls{angle of attack}, $\alpha$. This rotation matrix takes the form:
\begin{equation}\label{eq:LDMatrix}
 \begin{bmatrix}
     D'\\L'
 \end{bmatrix}
 =\begin{bmatrix}
        cos\alpha &sin\alpha\\
        -sin\alpha&cos\alpha
    \end{bmatrix}
    \begin{bmatrix}
        A'\\N'
    \end{bmatrix}
\end{equation}
We can expand \eqref{eq:LDMatrix} to give two scalar equations:
\begin{gather}
        L'=N'cos\alpha-A'sin\alpha\\
        D'=A'cos\alpha+N'sin\alpha
\end{gather}
So, if we know the distribution of pressure over our body, we have shown that we can find the resultant aerodynamic forces acting on our body. As briefly described in Section \ref{sec:moments}, another important parameter to find is our center of pressure.
\subsection{Center of Pressure}
Simply stated, the center of pressure is the location at which all the aerodynamic forces acting on a body produce no resultant moment. This location is particularly useful for our case because we can assume that the lift and drag forces act through the center of pressure rather than assuming that lift and drag act as force distributions. This will make our future calculations much more simple, so we would like to know the center of pressure and how to calculate it.

To find the location where the center of pressure occurs, we can take the moment about any point first. Often, we choose to take the moment about the nose of the rocket (called the leading edge when referring to a wing), since we define the origin here. This integral has a similar form to the normal and axial force integrals, except that we multiply the force by the distance from the nose. For more information on why this is done, refer to \cite{gundersen_understanding_2020}. Writing out this integral, we get:
\begin{gather}
    M_{LE}'=\int_0^c{p_u-p_l}{dx}+\int_0^c{\left(\tau_u\frac{dy_u}{dx}+\tau_l\frac{dy_l}{dx}\right)}{xdx}\\+\int_0^c{\left(p_u\frac{dy_u}{dx}+\tau_u\right)}{y_udx}+\int_0^c{\left(-p_l\frac{dy_l}{dx}+\tau_l\right)}{y_ldx}
\end{gather}
Knowing the normal force and the moment about the leading edge, we can find the center of pressure location as:
$$x_{cp}=\frac{-M_{LE}'}{N'}$$
We note that the convention for the moment about the nose is for a positive moment to denote a pitch up (this is why the negative sign is present). This is opposite the convention established by the \gls{rhr}. For all other moments used in our 6-\gls{dof} models, we use the standard \gls{rhr} convention for moments.

For more information on the derivation of the equations in this section, refer to Chapters 1 and 2 of \cite{anderson_fundamentals_2017}.

For a rocket, we generally consider the body to be \textit{axisymmetric} about the longitudinal axis, when the whole structure can be rotated about the axis which we define as $\hat{X}$. 

Because our rocket is axisymmetric, we assume that the center of pressure always lies along the longitudinal axis. Although this assumption is not necessarily true, as we will see later, the largest effects on the aerodynamic moments will occur from changes along the longitudinal direction rather than changes along the \textit{transverse plane. }We can think of this intuitively because of the center of pressure is separated from the center of mass by more than the diameter of the rocket, so changes in this direction have a greater effect.
\section{Atmospheric Modeling}
The first hurdle to overcome when describing the aerodynamics of our system is to find values for our \gls{freestream} quantities. We explore the calculation of $V_{\infty}$ in Section \ref{sec: Newtonian Dynamics}. The other parameters we need to calculate are $\rho_{\infty}$ and $a_{\infty}$. Fortunately, the standard density and Mach number of the atmosphere on Earth is well defined. In MATLAB, we can find this density at any altitude with "atmosisa" as:
\begin{lstlisting}[style=Matlab-editor]
    [T, a, P, rho] = atmosisa(height);
\end{lstlisting}
This gives us a standard value of $\rho_{\infty}$ and $a_{\infty}$ to use. However, the value of can vary by up to 10\% depending on the weather conditions \cite{svickova_air_2020}. Similarly, the Mach number has a strong dependence on temperature $\left(M=\sqrt{\gamma RT}\right)$, so the free-stream Mach number may also be different by 10-20\% of standard values. 

All of this is to say that using "atmosisa" gives us a good baseline model of the atmosphere, but is not the final say in atmospheric modeling. For now, we use "atmosisa" in our modeling because we can live with this variation in our model. However, it may be useful in the future to use other sources of atmospheric data that give location- and time-specific data.
\section{Computational Aerodynamics}
In the case of our rocket, we encounter a variety of flight regimes from subsonic to high supersonic. Because of this variety, hand calculations of our aerodynamics can become very complicated. As a result, we choose to use computational tools to compute the aerodynamics of our rocket.

\chapter{Numerical Integration Schemes}

\begin{chapquote}{Wolfgang Pauli}
    ''The best that most of us can hope to achieve in physics is simply to misunderstand at a deeper level.''
\end{chapquote}
For more information and derivations on the following section, refer to \cite{trench_31_2020}. This source includes some more information than included here and some useful examples.

\section{Euler Integration}
We have previously discussed the simplest integration scheme, the explicit Euler method, which we used in Section \ref{sec: Numerical Integration in the 1DoF}. Understanding the Euler method is key to understanding and using more complex integration schemes, so we recommend writing a few of your own Euler integration scripts in MATLAB or a coding language of your choice to really solidify your knowledge before moving on to more complex integration schemes. 

We formalize the explicit Euler integration below. Given a linear ODE:
$$y'=f\left(x,y\right)$$
With initial condition:
$$y(x_0)=y_0$$
We perform Euler integration first by defining an interval over which to perform the numerical integration. For Euler integration, we equally space these points by our timestep, $dt$. We can parameterize these points as:
$$x_i=x_0+i\Delta t$$
Our next step is to find the value of the tangent line at each point. This is trivial, since our differential equation tells us what $y'$ looks like at any value. All we have to do is evaluate:
$$y'=f\left(x_i,y(x_i)\right)$$
The problem here is that $y(x_i)$ is an unknown quantity (if we knew it, we wouldn’t have to do integration). So, to find the value of $y(x_i)$ we take an iterative approach. We know the starting value, $y(x_0)=y_0$, so we can find an approximation of the new value by multiplying the timestep by the current slope. For the first timestep, this will look like:
$$y_1=y_0+\Delta t\cdot f(x_0,y_0)$$
Now that we have found an approximation for $y_1$, we can extend this to find approximations for $y_2$, $y_3$, etc. This formula is generally extensible as:
$$y_{n+1}=y_i+\Delta t \cdot f(x_i,y_i)$$
We represent this Euler integration scheme graphically with a simple example. Suppose our differential equation is $y'=2x$ with initial condition $y(0)=0$. In this example, we can see from inspection that the solution curve is $y=x^2$. Performing Euler integration with a $\Delta t$ of 0.5 yields the black approximation in Figure \ref{fig:Euler}.
\begin{figure}[ht]
    \centering
    
\includegraphics[width=\linewidth]{Euler.png}
    \caption{Euler Method Numerical Approximation}
    \label{fig:Euler}
\end{figure}

As can be seen from the \ref{fig:Euler}, large timesteps quickly lead to error in the solution. For a strictly convex curve, our Euler approximation will always give us an under-approximation of the solution. In some cases, however, our solution may diverge so greatly that it becomes unstable and values tend toward infinity.\footnote{This is especially true for periodic functions. When working with periodic functions, make sure to sample well below the Nyquist limit.}

In Table 2 below, we describe the benefits and drawbacks of Euler integration.

%% add stupid table here

\subsection{Errors in the Euler Method}
We will use the example of the Euler Method to demonstrate error in numerical integrators. These same concepts will apply when we move on to higher order integrators. 

Errors in the integration scheme come from two different sources:
\newglossaryentry{trunc error}
{
    name=truncation error,
    first = {\textit{truncation error}},
    description={Error in numerical integration that comes from the inaccuracies of the integration scheme in modeling the true behavior of the function. This error is related to the number of higher order terms ignored}
}
1. Euler integration schemes only account for linear terms because it only considers the slope of the tangent line at a point. Thus, any quadratic order terms or higher will not be accounted for. Thus, the error is proportional to the timestep squared, $\Delta t^2$.\footnote{This intuitive explanation is not entirely correct, see (3) for a full derivation using the Taylor Series. We also note that the technically correct way to denote this is $O(\Delta t^2)$, meaning the error is of order $\Delta t^2$} We call this error \gls{trunc error}.
\newglossaryentry{roundoff error}
{
    name=roundoff error,
    first = {\textit{roundoff error}},
    description={Error in numerical integration that comes from inaccuracies in the floating point precision of computers. This is worsened by a larger number of timesteps, as this error will compound}
}
2. Another problem is the fact that computers don’t have infinite precision. The loss of precision during computing is called \gls{roundoff error}

It is worth noting that these errors are per timestep! So over the course of a full simulation, our errors will grow much larger than the error bounds that we’ve calculated above. In fact, for the Euler Method described above, the global error is proportional to the timestep, $\Delta t$.

We can of course, reduce errors in the simulation by reducing our timestep, $\Delta t$. However, this will also increase the computation time. Additionally, doing so will not reduce the \gls{roundoff error} in the simulation. With more calculations being done, the \gls{roundoff error} will have a larger impact. Thus, it is worthwhile to investigate other integration schemes.

\section{Improved Euler / RK2}
Given the limitations of the Explicit Euler method, we will start by investigating the improved Euler Method. This improved Euler method is the first of a family of integration schemes known as Runge-Kutta (RK) integration schemes. The number, 2, represents the order of the integration scheme, which we will explore more later.

The main area that led to inaccuracies in the explicit Euler method was the slope that we calculated. We can improve on this by taking two points and finding the average slope. We choose to take a point at our start and our end point,  and , and evaluate the slope at both of those points and average them. From the previous section, we can remember that:
\begin{equation}
    y'=f\left(x_i,y(x_i)\right)
\end{equation}
So, we can write the average slope as
\begin{equation}
    m=\frac{y_1'+y_2'}{2}
\end{equation}
Where
\begin{gather}
    y_1'=f\left(x_i,y(x_i)\right)\\
    y_2'=f\left(x_{i+1},y(x_{i+1})\right)
\end{gather}
Now that we have the slope, we follow the same process as we did for the Explicit Euler method to find the next value. We take the slope and multiply it by the timestep, $\Delta t$, and add the current value, $y(x_i)$. This gives us our approximation as:
\begin{equation}
    y=y(x_i)+\frac{y_1'+y_2'}{2}\Delta t
\end{equation}
We can write this then as:
\begin{equation}
    y_{i+1}=y_i+\frac{\Delta t}{2}\left[f(x_i,y(x_i))+f(x_{i+1},y(x_{i+1}))\right]
\end{equation}
To rewrite this equation in a way that is better suited for code:
\begin{gather}\label{eq:rk2}
    y_{i+1}=y_i+\frac{\Delta t}{2}(k_1+k_2)\\\\
    k_1=f(x_i,y_i)\\
    k_2=f(x+\Delta t, y_i+\Delta tk_1)
\end{gather}
We can note here that this method requires at least two evaluations since $k_2$ is dependent on $k_1$. However, this is often still more computationally efficient than the Explicit Euler method because larger time steps can be used with lesser error.

\subsection{RK2 in Code}
\newglossaryentry{func handle}
{
    name=function handle,
    first = {\textit{function handle}},
    description={A pointer to an instance of a function in MATLAB. A function handle essentially stores a function call in a variable in MATLAB.}
}
Implementing the RK2 algorithm in code is slightly more complicated than implementing the explicit Euler method. To properly implement this, we will use \glspl{func handle} in MATLAB. \Glspl{func handle} act as pointers to an instance of a function. To explain what that means, we will examine the following code snippet:
\begin{lstlisting}[style=Matlab-editor]
f = @computeSquare;
a = 4;
b = f(a)
\end{lstlisting}
where "computeSquare" is defined as:
\lstset{style=mystyle}
\begin{lstlisting}[style=Matlab-editor]
function y = computeSquare(x)
y = x.^2;
end
\end{lstlisting}
The \gls{func handle} allows us to assign the function to a variable, which we are calling "f". We call this a pointer because this variable ‘points’ to the function "computeSquare".

In this example, when we call this operation, we get "b=16" in the command window. The power of this is that we could instead pass in a vector of values for "a" and get outputs from the function for all of them. If we instead input:
\begin{lstlisting}[style=Matlab-editor]
f = @computeSquare;
a = [4,6,10];
b = f(a)
\end{lstlisting}
We get an output of "b = 16  36  100". The usefulness of this is immediately apparent for numerical integration. We can pass in a vector of many different times and get outputs for each of them. 

Another useful feature of \glspl{func handle} for numerical integration is that they allow us to pass in only the variables needed for numerical integration and pass other variables in the expression as constants. In general, we want our numerical scheme to only accept our \gls{state vector} and the time vector. This is the same thing that "ode45" does, so it is best practice to do the same thing here.

Our RK2 algorithm is a direct translation of \eqref{eq:rk2} into code. We present this below in Listing \ref{code:rk2}:
\begin{lstlisting}[style=Matlab-editor, caption=RK2 Integrator]
%% RK2 Integrator
% numerically integrates a first order initial value problem using Runge-Kutta 2nd order.
% inputs:
% fun - function of integration
% dt - time step [s]
% tIn - input time [s]
% xIn - initial value input vector
% outputs:
% out - final value output vector
function out = rk4(fun, dt, tIn, xIn)
    f1 = fun(tIn,xIn);
    f2 = fun(tIn + dt/2, xIn + dt .* f1);
    
    out = xIn + (dt / 2)*(f1 + f2);
end
\end{lstlisting}\label{code:rk2}
%% add more on making functions and rk2.

\section{RK4 Integration}
RK4 integration is the last major integration scheme that we will explore. RK4 integration is often the best balance between the precision of the algorithm and the speed of computation. 

To explain the RK4, we will go back to the RK2 and explain it in a slightly different way that will shed light on what we are doing with RK4. In RK2, we described taking the average slope of the function. We can also imagine taking the Taylor expansion of our function:
$$y_{i+1}=y_i+y_i'\Delta t+y_i''\frac{\Delta t}{2}+O\left(\Delta t^3\right)$$
From this Taylor expansion of the solution, we can that our approximation accounts for linear and quadratic terms. Thus, our error is proportional to terms to the 3\textsuperscript{rd} power, represented by $O(\Delta t^3)$. We know $y_i$ and $y_i'$, but the 2nd  order derivative of our function is unknown. We can approximate this 2nd order derivative as:
$$y_i=\frac{y'_{i+1}-y_i'}{\Delta t}$$
Upon rearranging this equation, we can see that we arrive at the same expression as we did before. We can apply the same approach for the RK4 integration, except we consider terms up to the 4\textsuperscript{th} order expansion of the Taylor series:
$$y_{i+1}=y_i+y_i'\Delta t+y_i''\frac{\Delta t}{2}+y_i'''\frac{\Delta t}{6}+y_i''''\frac{\Delta t}{24}O\left(\Delta t^5\right)$$
Immediately, we can see that our error has shrunk to be proportional to terms of the 5\textsuperscript{th} order, a dramatic reduction as compared to RK2 or Explicit Euler method.

\subsection{RK4 Integration in Code}
The RK4 Integration scheme can be expressed as a set of equations very similar to what we did with \eqref{eq:rk2}. We will not derive these equations here, because the process is very similar to that used for the RK2 method.

The form of these equations is shown in \eqref{eq:RK4}.
\begin{gather}\label{eq:RK4}
    y_{i+1}=y_i+\frac{\Delta t}{6}\left(k_1+2k_2+2k_3+k_4\right)\\\\
    k_1=f(x_i,y_i)\\
    k_2=\left(x_i+\frac{\Delta t}{2},y_i+\frac{\Delta t}{2}k_1\right)\\
    k_3=\left(x_i+\frac{\Delta t}{2},y_i+\frac{\Delta t}{2}k_2\right)\\
    k_4=f(x_i+\Delta t,y_i+\Delta tk_3)
\end{gather}
An implementation of this algorithm into code is shown below.
\begin{lstlisting}[style=Matlab-editor, caption=RK4 Integrator]
%% RK4 Integrator
% numerically integrates a first order initial value problem
% inputs:
% fun - function of integration
% dt - time step [s]
% tIn - input time [s]
% xIn - initial value input vector
% outputs:
% out - final value output vector
function out = rk4(fun, dt, tIn, xIn)
    f1 = fun(tIn,xIn);
    f2 = fun(tIn + dt/2, xIn + (dt/2) .* f1);
    f3 = fun(tIn + dt/2, xIn + (dt/2) .* f2);
    f4 = fun(tIn + dt, xIn + dt*f3);
    
    out = xIn + (dt / 6)*(f1 + 2*f2 + 2*f3+f4);
end
\end{lstlisting}
Often, we use a function in MATLAB called "ode45" to perform RK4 integration. This function has the benefit that it will change the step size to produce high accuracy when needed and decrease computation time otherwise.

An understanding of the operation of "ode45" is best motivated by an example. We include an example of a Lorenz Attractor in the Appendix \ref{sec:Lorenz Attractor RK4 Example} as an example of ode45. We recommend reading through this code and running it, as well as changing parameters to see how it affects the outputs.
\section{Other Integration Schemes}

\section{Code Optimization with Numerical Integration}
\subsection{Monte Carlo Simulation}
Often, we want to run many simulations with various parameters to gain a better understanding of our system. We call this method of running many simulations the \textit{Monte Carlo} method. Using the Monte Carlo method, we can ascertain information about the likelihood of certain events or approximate quantities that are hard to find analytically by running a large number of simulations and performing statistical analysis on the results. In this document, we will not dive into the methods of statistical analysis and the best ways to perform Monte Carlo simulations. This topic is very deep and is the focus of many peoples’ whole careers.

However, even with only rudimentary analysis, Monte Carlo can prove very useful. We will use the example of Monte Carlo to motivate the need for fast simulations. Often, we run upwards of 1000 simulations and fast computation is necessary to perform this large number of simulations. In this section, we will dive into the various methods to optimize MATLAB code and best practices for flight dynamics.
\subsection{Array and Function Optimizations}
MATLAB is generally quite computationally efficient at computing arrays and matrices. After all, MATLAB is ‘MATrix LABoratory’. However, we still need to be mindful of optimizations to our code.

It is best practice to only import what you need for a function or subroutine. For example, if you have wind data for all of the months out of the year, it is desirable to cull that down to the specific month before running the simulation.

Additionally, it is also beneficial for any imported data or long matrices to be passed into a function rather than called inside a function. \textbf{This is especially important inside the numerical integration scheme! }Running readmatrix inside of ode45 or whichever other numerical integration scheme you are using can slow down code upwards of 500\% depending on the length of the matrices being read.

Instead, it is best to pass these arrays into the function. Performing readmatrix can be slow because it must check if the values are numeric and organize them into tables. By passing only MATLAB arrays, computations are much faster.
\subsection{Flame Graphs for Optimization}
One important method of optimization is the MATLAB profiler. The primary capability of the profiler is the flame graph. An example of the flame graph is shown below in Figure 15.

The flame graph gives a visual representation of how long the code spends on each function. Functions in blue are those defined by the user. Those in grey are built in MATLAB functions.

%% Figure here
Poorly optimized code will spend a long time running an excessive number of operations. In some cases, this is unavoidable. For example, ode45, which runs the RK4 integration scheme we discussed in section 5.3, must run for every time step and is likely to comprise a large part of simulation time.

However, other operations, such as "atmosisa", should not comprise a large portion of simulation time. As seen in Figure 15, calling the atmosisa function on every loop takes about 40\% of the total time spent in ‘RK4Integrator’ function. By instead creating a table of the atmosisa data before running the simulation, we can reduce the runtime quite drastically. Implementing this simple change, we can see the reduction in simulation time as shown in Figure 16.

% figure here


\chapter{The 6-DoF}
In this section we will combine everything from the previous sections and explain how our 6-\gls{dof} model works. We will follow a similar set up to \ref{sec:Dzhan}  here, describing the elements of the model in detail and then attaching relevant code either in-line or in the appendix.

Our definitions of our frames follow from those discussed in \ref{sec:Frame of Reference}. For the earth-centered inertial frame, we follow the conventions discussed in \ref{fig:InertialFrame}. Recall that the $\hat{x}$ axis points upward toward the zenith, the $\hat{y}$ axis points east along the surface, and the $\hat{z}$ axis finishes the right-handed coordinate system, pointing north.

For the body frame, we follow the convention in \ref{fig:BodyFrameRocket}. This has $\hat{X}$ pointing through the nose of the rocket and $\hat{Y}$and $\hat{Z}$ along the transverse plane. The directionality of $\hat{Y}$ and $\hat{Z}$ is not particularly important since the rocket is axially symmetric, so we arbitrarily select the $\hat{Y}$ axis to point through one of the fins and choose $\hat{Z}$ to complete the right-handed frame.

For our \gls{Euler angles}, we use a 3-2-1 rotation sequence. We define the zero angles to be when the body frame and the earth-centered inertial frame are coincident.
\section{State Vector}
Our \gls{state vector} is very similar to that shown in the \ref{sec:Dzhan} section, but it bears repeating here because there are some important differences. Another thing to note is that some of the values of the \gls{state vector} are altered for Monte Carlo simulations. These possible changes, when applicable, are discussed.

We define our original position at the origin, giving us a position vector. It is also possible to define our initial position in another coordinate system, such as (lat, long, elevation). Generally it is good practice to set the origin to zero and add any offsets later to keep floating point errors in numerical integration small:
$$\vec{r}_0=\begin{bmatrix}
    0\\0\\0
\end{bmatrix}$$
We also define the initial velocity to be zero, giving a velocity vector. Since velocity is frame independent for an observer at rest with respect to our inertial frame, this is almost always zero. We may see an initial velocity if we are modeling a sounding rocket launched with an initial speed or similar for validation of our model:
$$\vec{v}_0=\begin{bmatrix}
    0\\0\\0
\end{bmatrix}$$
We also need the initial orientation. Here, we use \gls{Euler angles} again. We often choose to launch at a slight angle to simulate adverse affects that may push the launch vehicle slightly off-course during the initial launch. We choose to add a small angle in the $\theta$ and $\psi$ directions in this case:
\begin{equation}\label{eq: euler angles 6DoF}
    \begin{bmatrix}
    \phi\\\theta\\\psi
\end{bmatrix} =
\begin{bmatrix}
    0\\0.1\\0.1
\end{bmatrix}
\end{equation}
We note that we could also parametrize this as a $45\degree$ rotation on the $\phi$ axis and then a $0.1$ radian angle on either the $\theta$ or the $\psi$ axis. For different scenarios one may be more useful than another. For example, if we want to simulate a $10\degree$ launch angle (from zenith), we can then use the $\phi$ angle to determine the azimuth at which we launch.

We use the command "eul2quat" with a specification of "XYZ" for the frame. The specificiation is important now because we need to explicitly define our rotation sequence when two or more rotations are present. In the case of \eqref{eq: euler angles 6DoF}, this gives an the initial \gls{quaternion} vector of :
$$\vec{q}_0=\begin{bmatrix}
    0.9975\\0.0025\\0.0499\\0.0499
\end{bmatrix}$$
\newglossaryentry{rail whip}
{
    name=rail whip,
    first={\textit{rail whip}},
    description={A phenomenon where the flexibility of the launch rail causes a large moment to be exerted on the rocket during launch.}
}
Lastly, we need to describe the initial angular velocity. We assume for most simulations that there is no angular velocity. For some cases, such as the simulation of \gls{rail whip}, we may choose to put an angular velocity on the rocket.
$$\vec{\omega}_0=\begin{bmatrix}
0\\0\\0
\end{bmatrix} rad/s$$
Putting all of the together, we arrive at our \gls{state vector}:
$$\vec{X}_0=\begin{bmatrix}
    \vec{r}_0\\\vec{v}_0\\\vec{\omega}_0\\\vec{q}_0
\end{bmatrix}$$
\section{Forces and Moments in the 6-DoF}
The forces and moments on our rocket are what separate this case from the more simple case of the Dzhanibekov effect in \ref{sec:Dzhan}. We have discussed most of these forces in \ref{fig:3 DoF Forces}, and in the \ref{sec: aerodynamics}, but the exact implementation into the 6-DoF model bears repeating, specifically relating to frame conversion.
\subsection{Forces}
We define 4 main forces that act on the vehicle, those being the 4 forces described in section \ref{sec: 3DoF Case}. We will start with the most simple, which is gravity.
\subsubsection{Gravity}
Because we define the $\hat{x}$ direction as the zenith direction in the inertial earth frame, we define gravity as:
\begin{equation}
   F_g= \begin{bmatrix}
    -mg\\0\\0
\end{bmatrix}
\end{equation}
For gravity, we note that because it acts through the center of mass of the rocket, we do not have a resultant moment to worry about.
\subsubsection{Thrust}
Thrust is also fairly simple to model. If we consider the thrust to be coincident to the longitudinal axis, the thrust is given by \eqref{eq:Ft}. For the magnitude, we consider a slightly more complex model than before. Because the rocket is changing altitude, the thrust of the engine will change as the pressure changes. The thrust of the engine, accounting for this pressure change, is given by:
\begin{equation}
    F_T=\dot{m}V_e+\left(P_{e}-P_{atm}\right)\cdot A_e
\end{equation}
Where $\dot{m}$ is the mass flow rate of the engine, $V_e$ is the exit velocity of the engine, $P_e$ is the exit pressure of the engine, $P_{atm}$ is the atmospheric pressure, and $A_e$ is the area of the nozzle exit. For a propulsion, these parameters are usually specified or can be easily derived, although we will not do so here. See \cite{noauthor_chemical_nodate} or the propulsion team for more details.

Here, we introduce the use of the rotation matrix to convert between different frames. MATLAB allows for the creation of a rotation matrix with the input of a \gls{quaternion} using the "quat2dcm" function. Using this, we can perform frame conversion to and from the body and earth frame. We show this below in \ref{code:RotationMatrix}:
\lstinputlisting[style=Matlab-editor, caption = Rotation Matrix]{RotationMatrix.m}\label{code:RotationMatrix}
Using this code, we can convert the thrust from the body frame into the earth frame through the function call "RotationMatrix(thrustForceBody, quat, 1)". The input of 1 in this function means that the vector is transformed from the body frame into the earth frame. In our case, this means that we multiply by the transpose of the rotation matrix in the MATLAB notation convention.
\subsubsection{Lift and Drag}
Our other two forces follow in a similar manner. The quantities of lift and drag are heavily discussed in \ref{sec: aerodynamics}, so we will keep them succinct here. The directions of lift and drag in the earth frame are described by \eqref{eq:Lift} and \eqref{eq:drag}. To convert these forces into the body frame, we use the function call "RotationMatrix(force, quat, 0)". The specification of "0" in the function converts a force in the earth frame into one in the body frame. We need the body frame force for computing the moments in the body frame, as discussed in \ref{sec:rotations in the body frame}.
\subsubsection{Parachute Forces}
The other force that sometimes acts on our rocket is a parachute force. This acts as another body with drag that is activated in the post-apogee regime. This drag has the same form as the aerodynamic drag, $\frac{1}{2}\rho_{\infty} V_{\infty}^2SC_D$ with the drag acting opposite the freestream velocity. In code, this looks like:
\begin{lstlisting}[style=Matlab-editor]
forceMag = 0.5 * totCd * vertArea * rho * norm(vel)^2;
paraDragForce = forceMag .* (-vel ./ norm(vel)); 
\end{lstlisting}
This force is only active when the vertical velocity is negative, so this is controlled by an "if/else" structure as: "if vel(1) < 0"
\subsection{Moments}

\section{Validation of 6-DoF}
\chapter{Appendix}
\section{Notation}
Mathematical notation for the subjects that we discuss is largely formalized and commonly used, but there are some areas where we may use notation slightly unfamiliar or different to what you have seen in the past. You may also see different notation when looking at papers and literature for future work on the 6-\gls{dof}. To remove any doubt, we describe the notation that we use here.

For derivatives with respect to time, we will use the compact Newtonian notation. For example, $\dot{x}=\frac{dx}{dt}$, $\ddot{x}=\frac{d^2x}{dt^2}$, and so on. 

For vectors, any vector with a hat like $\hat{x}$ refers to a vector with a magnitude of 1 (normalized vector). These are often seen as basis vectors or unit vectors describing the direction of a force. Vectors with a ‘arrow’ hat like $\hat{x}$ refers to a general vector with a non-normalized magnitude. Vectors with a non-normalized magnitude may also be represented by a bold-faced symbol such as in the case of Euler angle rates. When taking the time derivative of a vector, we prefer to write using this boldface notation, such as $\dot{\textbf{x}}$ instead of $\dot{\vec{x}}$.

For short pieces of code written inline, we use a mono-spaced font with the appearance of "code snippet" as shown. Longer code is included in listings with line numbers using the same font.

\section{Proofs and Derivations}\label{sec:ProofsAndDerivations}



\subsection{Vector Projection Simplification}\label{sec:VecProjectSimplify}
Proof by: Preston Wright

In section \ref{sec:PrincipleAxisRotationMatrix}, we describe a simplification to the projection of our vector $\vec{x}$ onto the \gls{Euler axis} $\vec{n}$ as:
$$\vec{x}_\parallel=(\vec{x}\cdot\vec{n})\vec{n}=(\vec{n}\vec{n}^T)\vec{x}$$
\begin{proof}
While trivial, we wanted to show the proof here just to clarify that this equality holds. We will use the same notation for our vectors for obvious reasons; however, keep in mind this equality holds for any two arbitrary vectors of identical dimensions [e.g. ($\vec{x},\vec{n}\in\mathbb{R}^m$)]\footnote{While we typically denote spaces by $\mathbb{R}^n$, $n$ is already used as a variable for one of our vectors. Therefore, m will be used as a substitute to define the dimension in order to improve clarity.}. To start, we can visually expand the first form $(\vec{x}\cdot\vec{n})\vec{n}$ using the finite summation form of a dot product between two vectors of length $m$: $$\vec{x}_\parallel=\vec{n}\sum_{i=1}^{m}{x_in_i}$$ 
Where each term of the vector $\vec{n}$ will be multiplied by that summation in a scalar multiplication operation. We can explicitly write this as:
$$\vec{x}_\parallel=\begin{bmatrix}
    n_1(x_1n_1+x_2n_2+\ldots+x_in_i)\\
    \vdots\\
    n_i(x_1n_1+x_2n_2+\ldots+x_in_i)
\end{bmatrix}$$

The second form $(\vec{n}\vec{n}^T)\vec{x}$ takes a different approach, simply favoring matrix multiplication over scalar multiplication. By computing the initial multiplication of $\vec{n}$ by its own transpose, this form becomes the matrix multiplication of an $[i\times i]$ matrix with the vector $\vec{x}$ of length $i$:
$$\vec{x}_\parallel=\begin{bmatrix}
    n_1^2&n_1n_2&\ldots&n_1n_i\\
    n_2n_1&n_2^2&\ldots&n_2n_i\\
    \vdots&\vdots&\ddots&\vdots\\
    n_in_1&n_in_2&\ldots&n_i^2
\end{bmatrix}\begin{bmatrix}
    x_1\\x_2\\\vdots\\x_i
\end{bmatrix}$$
Computing the matrix multiplication gets us the following:
$$\vec{x}_\parallel=\begin{bmatrix}
    n_1^2x_1+n_1n_2x_2+\ldots+n_1n_ix_i\\
    \vdots\\
    n_in_1x_1+n_in_2x_2+\ldots+n_i^2x_i
\end{bmatrix}$$
Factoring out the common number $n_i$ in every row, we get:
$$\vec{x}_\parallel=\begin{bmatrix}
    n_1(x_1n_1+x_2n_2+\ldots+x_in_i)\\
    \vdots\\
    n_i(x_1n_1+x_2n_2+\ldots+x_in_i)
\end{bmatrix}$$
Which, lo and behold, is identical to our answer for the first form of the projection. Thus, we have successfully proven the equality of these two forms for the term $\vec{x}_\parallel$.
\end{proof}




\subsection{Quaternion Multiplication Matrix}\label{sec:QuatMultiplyMatrix}







\subsection{Characteristic Polynomial Derivation for Degree 3}

% Maybe don't do its hella long lmao

\section{Code}
This section contains lengthier segments of example code from either the 6-\gls{dof} itself or a proof/example relating to it. Refer to the section numbers to find the appropriate implementation of each code segment.
\subsection{Lorenz Attractor RK4 Example}\label{sec:Lorenz Attractor RK4 Example}
\lstinputlisting[style=Matlab-editor, caption = Lorenz Attractor]{LorenzAttractor.m}\label{code:Lorenz}

We also have a script to display the results of this in a nice animation:

\lstinputlisting[style=Matlab-editor, caption =Lorenz Animation]{LorenzAnimation.m}\label{code:LorenzAnim}
\subsection{Dzhanibekov Effect Model}
\lstinputlisting[style=Matlab-editor, caption = Dzhanibekov Main]{DzhanibekovMain.m}\label{code:DzhanMain}

\lstinputlisting[style=Matlab-editor, caption = Dzhanibekov Integrator]{DzhanibekovIntegrator.m}\label{code:DzhanInt}

\lstinputlisting[style=Matlab-editor, caption = Dzhanibekov Rotation Visualizer]{RotationsVisualizer.m}\label{code:DzhanRotVis}\


\setglossarystyle{altlist}
\printglossary[title=Special Terms, toctitle = Special Terms]

\printbibliography[heading=bibintoc, title={References}]

\end{document}
